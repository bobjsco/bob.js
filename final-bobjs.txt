(() => {
    // ==========================================
    // 1. AUDIO SYSTEM (Complex Sound Synthesis + Input Analysis)
    // ==========================================
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    let analyser, audioSource, audioDataArray, audioInitialized = false;
    let audioIntensity = 0; // Bass/Volume 0.0 to 1.0
    let audioPitch = 0;     // Pitch 0.0 to 1.0 (High freq)
    
    function playSound(type) {
        try {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            switch (type) {
                case 'bounce':
                    oscillator.frequency.value = 200 + Math.random() * 50;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'collision':
                    oscillator.frequency.value = 150 + Math.random() * 30;
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'explosion':
                    oscillator.frequency.value = 50 + Math.random() * 20;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'click':
                    oscillator.frequency.value = 800 + Math.random() * 100;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.05);
                    break;
                case 'whoosh':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(
                        100 + Math.random() * 50,
                        audioCtx.currentTime + 0.3
                    );
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'rolling':
                    oscillator.frequency.value = 60 + Math.random() * 20;
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
            }
        } catch (e) {
            // Audio might be blocked
        }
    }

    // Audio Analysis Helper
    async function startAudio() {
        if (audioInitialized) return;
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 512;
            audioSource = audioCtx.createMediaStreamSource(stream);
            audioSource.connect(analyser);
            audioDataArray = new Uint8Array(analyser.frequencyBinCount);
            audioInitialized = true;
            console.log("Audio Engine Started (External Input)");
        } catch (err) {
            console.error("Audio Error:", err);
        }
    }

    function updateAudioData() {
        if (!audioInitialized) { audioIntensity = 0; audioPitch = 0; return; }
        
        analyser.getByteFrequencyData(audioDataArray);
        
        // 1. Calculate Intensity (Volume/Bass) - Average of lower frequencies
        let bassSum = 0;
        for (let i = 0; i < 20; i++) bassSum += audioDataArray[i];
        audioIntensity = (bassSum / 20) / 255;
        
        // 2. Calculate Pitch (High Freq) - Average of high frequencies
        let highSum = 0;
        const highIndexStart = 100;
        for (let i = highIndexStart; i < audioDataArray.length; i++) highSum += audioDataArray[i];
        audioPitch = (highSum / (audioDataArray.length - highIndexStart)) / 255;

        // Threshold
        if (audioIntensity < 0.1) audioIntensity = 0;
        if (audioPitch < 0.05) audioPitch = 0;
    }
    
    // === Setup canvas ===
    const canvas = document.createElement('canvas');
    Object.assign(canvas.style, {
        position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', zIndex: 1, touchAction: 'none', opacity: '0'
    });
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    
    // === OPTIMIZATION: Spatial Grid for Collision Detection ===
    class SpatialGrid {
        constructor(cellSize) { this.cellSize = cellSize; this.cells = new Map(); }
        clear() { this.cells.clear(); }
        getKey(x, y) { return `${Math.floor(x/this.cellSize)},${Math.floor(y/this.cellSize)}`; }
        addObject(obj) {
            const startX = Math.floor(obj.x/this.cellSize);
            const startY = Math.floor(obj.y/this.cellSize);
            const endX = Math.floor((obj.x+obj.w)/this.cellSize);
            const endY = Math.floor((obj.y+obj.h)/this.cellSize);
            for (let x = startX; x <= endX; x++) {
                for (let y = startY; y <= endY; y++) {
                    const key = `${x},${y}`;
                    if (!this.cells.has(key)) this.cells.set(key, []);
                    this.cells.get(key).push(obj);
                }
            }
        }
        getNearbyObjects(obj) {
            const nearby = new Set();
            const startX = Math.floor(obj.x/this.cellSize);
            const startY = Math.floor(obj.y/this.cellSize);
            const endX = Math.floor((obj.x+obj.w)/this.cellSize);
            const endY = Math.floor((obj.y+obj.h)/this.cellSize);
            for (let x = startX; x <= endX; x++) {
                for (let y = startY; y <= endY; y++) {
                    const objects = this.cells.get(`${x},${y}`);
                    if (objects) objects.forEach(o => { if (o !== obj) nearby.add(o); });
                }
            }
            return Array.from(nearby);
        }
    }
    
    // === Physics constants (base) ===
    let gravity = 0.6;
    let gravityDir = 1;
    let friction = 0.85;
    let wallBounce = 0.75;
    let restitution = 0.8;
    let collisionsEnabled = true;
    let blockSize = 100;
    let airResistance = 0.999;
    let angularDamping = 0.98;
    let magnetStrength = 3;
    let slowMo = 1;
    
    // === OPTIMIZATION: Performance settings ===
    const performanceSettings = {
        spatialGridSize: 150,
        collisionCheckInterval: 2,
        particleUpdateInterval: 2,
        renderInterval: 1
    };
    
    // === Unified Physics Settings ===
    let physicsSettings = {
        gravity, airResistance, angularDamping, restitution, friction, wallBounce,
        magnetStrength: magnetStrength * 50,
        collisionEnergyLoss: 0.15,
        angularVelocityTransfer: 0.5,
        particleEmissionRate: 5,
        particleLife: 100,
        particleSize: 3,
        explosionParticles: 20,
        trailLength: 10,
        shadowBlur: 15,
        shadowOpacity: 0.5,
        trailOpacity: 0.3,
        glowIntensity: 1.0,
        timeScale: 1.0
    };
    
    function applyPhysicsSettings() {
        gravity = physicsSettings.gravity;
        airResistance = physicsSettings.airResistance;
        angularDamping = physicsSettings.angularDamping;
        restitution = physicsSettings.restitution;
        friction = physicsSettings.friction;
        wallBounce = physicsSettings.wallBounce;
        magnetStrength = physicsSettings.magnetStrength / 50;
    }
    
    physicsSettings.restitution = 1.0;
    physicsSettings.wallBounce = 1.0;
    physicsSettings.collisionEnergyLoss = 0.0;
    applyPhysicsSettings();
    
    // === Target size for shrink/grow modes ===
    let targetSize = { width: blockSize, height: blockSize };
    
    // === Effect flags ===
    let rainbowMode = false;
    let shrinkMode = false;
    let growMode = false;
    let trailMode = false;
    let flashMode = false;
    let colorCycle = false;
    let randomFrameColors = false;
    let gravityWave = false;
    let gravitySpin = false;
    let magnetize = false;
    let magnetInvert = false;
    let centerPull = false;
    let verticalMovement = true;
    let horizontalMovement = true;
    let rotateMode = false;
    let tornadoMode = false;
    let sizeWaveMode = false;
    let antiGravityMode = false;
    
    // === NEW FLAGS FOR GEOMETRY & VISUALS ===
    let infiniteBounceMode = false;
    let randomSizeMode = false;
    let jitterMode = false;
    let glassMode = false;
    let wireframeMode = false;
    let shadowMode = false;
    let glowMode = false;
    let neonMode = false;
    let mirrorMode = false;
    let outlineOnly = false;
    
    // === NEW FLAGS FOR VOICE/AUDIO ===
    let audioPulseMode = false;
    let pitchSizeMode = false;
    let voiceShakeMode = false;
    let voiceSpawnMode = false;

    // === NEW FLAGS FOR CHAOS (20 Random Buttons) ===
    let hyperSpeed = false;
    let pixelate = false;
    let invertColors = false;
    let glitchMode = false;
    let spiralForce = false;
    let jitterPhysics = false;
    let elasticWalls = false;
    let darkMode = false;
    let bigBertha = false;
    let tinyTims = false;
    let chaosSpawner = false;
    let lockMouse = false;
    let gravityTunnel = false;
    let neonRain = false;
    let discoMode = false;
    let electronMode = false;
    let shakeCam = false;
    let perimeterOnly = false;
    let rainbowEdges = false;
    let resetZoom = false; // Dummy flag for reset logic
    
    // === Color Pulsing System ===
    let colorPulseMode = false;
    let pulseColor1 = '#ff595e';
    let pulseColor2 = '#1982c4';
    let pulsePhase = 0;
    let pulseSpeed = 0.05;
    
    // === Particle Effects System ===
    let flamingParticlesActive = false;
    let mouseTrailActive = false;
    let snowfallActive = false;
    let sparklerActive = false;
    let starfieldActive = false;
    let rainActive = false;
    let bubblesActive = false;
    let fireworksActive = false;
    let smokeTrailActive = false;
    let electricityActive = false;
    let pixelDustActive = false;
    let cosmicWindActive = false;
    let auroraActive = false;
    let plasmaActive = false;
    let nebulaDriftActive = false;
    
    // === Illusion flags ===
    let illusionsActive = {
        spiral: false, breathingGrid: false, waveTunnel: false, vortex: false,
        orbitRing: false, checkerSpin: false, flipStrip: false, zoomPulse: false,
        swirlField: false, hypnoHue: false
    };
    
    // === Sound cooldown system ===
    const soundCooldowns = { bounce: 0, collision: 0, rolling: 0 };
    const SOUND_COOLDOWN_TIME = 100;
    
    const colors = ['#ff595e', '#8ac926', '#1982c4', '#ffca3a', '#6a4c93'];
    const shapes = ['rectangle', 'circle', 'triangle'];
    
    // === OPTIMIZATION: Create spatial grid ===
    const spatialGrid = new SpatialGrid(performanceSettings.spatialGridSize);
    let frameCount = 0;
    
    // === Block factory ===
    function makeBlock(x, y, color = randomColor(), shape = randomShape()) {
        let w = blockSize;
        let h = blockSize;
        if (randomSizeMode) {
            w = blockSize * (0.5 + Math.random() * 1.5);
            h = blockSize * (0.5 + Math.random() * 1.5);
        }
        // Chaos: Big Bertha
        if (bigBertha) { w = 250; h = 250; }
        // Chaos: Tiny Tims
        if (tinyTims) { w = 10; h = 10; }

        return {
            x, y, w: w, h: h, color,
            vx: (Math.random() - 0.5) * 2, vy: 0,
            isDragging: false, shape, mass: 1,
            rotation: 0, rotationSpeed: (Math.random() - 0.5) * 0.1, angularVelocity: 0,
            displayW: w, displayH: h,
            elasticity: restitution, friction,
            momentOfInertia: (1 * (w * w + h * h)) / 12,
            trail: [], maxTrailLength: 20
        };
    }
    
    let blocks = [makeBlock(200, 100), makeBlock(360, 100), makeBlock(520, 100)];
    const activeCollisions = new Set();
    const dynamites = [];
    const particles = [];
    const effectParticles = [];
    
    // Mouse positions
    let mouseX = 0, mouseY = 0, lastMouseX = 0, lastMouseY = 0, prevMouseX = 0, prevMouseY = 0;
    
    function makeDynamite(x, y) {
        return { x, y, vx: 0, vy: 0, w: 20, h: 50, timer: 180, exploded: false, color: 'red', isDragging: false };
    }
    
    // === OPTIMIZATION: Particle pooling ===
    const particlePool = [];
    function makeParticle(x, y, color) {
        if (particlePool.length > 0) {
            const p = particlePool.pop();
            p.x = x; p.y = y; p.vx = (Math.random() - 0.5) * 15; p.vy = (Math.random() - 0.5) * 15;
            p.life = 100; p.color = color; p.size = Math.random() * 6 + 2; p.gravity = 0.2; p.airResistance = 0.98;
            return p;
        }
        return { x, y, vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15, life: 100, color, size: Math.random() * 6 + 2, gravity: 0.2, airResistance: 0.98 };
    }
    
    function makeEffectParticle(type, x, y) {
        const base = { x, y, life: 100, maxLife: 100, size: 2, type };
        if (type === 'flame') return { ...base, vx: (Math.random()-0.5)*3, vy: -Math.random()*4-2, color: `hsl(${Math.random()*60},100%,${50+Math.random()*30}%)`, size: Math.random()*10+4, life: 80, gravity: -0.1 };
        if (type === 'mouseTrail') return { ...base, vx: (Math.random()-0.5)*1, vy: (Math.random()-0.5)*1, color: `hsl(${Math.random()*360},70%,60%)`, size: Math.random()*8+3, life: 40, gravity: 0 };
        if (type === 'snow') return { ...base, vx: (Math.random()-0.5)*0.8, vy: Math.random()*1.5+0.5, color: '#ffffff', size: Math.random()*5+2, life: 400, gravity: 0.05 };
        if (type === 'sparkle') return { ...base, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, color: `hsl(${Math.random()*60+40},100%,80%)`, size: Math.random()*4+1, life: 50, twinkle: Math.random()*Math.PI*2, gravity: 0 };
        if (type === 'star') return { ...base, vx: 0, vy: Math.random()*0.8+0.2, color: `hsl(${Math.random()*60+200},70%,80%)`, size: Math.random()*3+1, life: 600, gravity: 0.01 };
        if (type === 'rain') return { ...base, vx: Math.random()*3-1, vy: Math.random()*10+8, color: 'rgba(100,150,255,0.7)', size: Math.random()*3+1, life: 200, gravity: 0.3 };
        if (type === 'bubble') return { ...base, vx: (Math.random()-0.5)*1.5, vy: -Math.random()*3-1, color: `hsla(${Math.random()*60+180},50%,80%,0.3)`, size: Math.random()*18+7, life: 250, float: Math.random()*Math.PI*2, gravity: -0.05 };
        if (type === 'firework') return { ...base, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, color: `hsl(${Math.random()*360},100%,60%)`, size: Math.random()*5+2, life: 100, gravity: 0.15, airResistance: 0.97 };
        if (type === 'smoke') return { ...base, vx: (Math.random()-0.5)*1.5, vy: -Math.random()*3-1, color: `rgba(100,100,100,${0.5 - Math.random()*0.3})`, size: Math.random()*12+6, life: 120, gravity: -0.02, airResistance: 0.95 };
        if (type === 'electric') return { ...base, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, color: `hsl(${Math.random()*60+180},100%,80%)`, size: Math.random()*4+1, life: 25, intensity: Math.random(), gravity: 0, airResistance: 0.9 };
        if (type === 'pixelDust') return { ...base, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, color: `hsl(${Math.random()*360},80%,70%)`, size: 2, life: 150, gravity: 0.05 };
        if (type === 'cosmic') return { ...base, vx: Math.random()*4+2, vy: (Math.random()-0.5)*1.5, color: `hsl(${Math.random()*60+280},70%,60%)`, size: Math.random()*4+1, life: 250, gravity: 0.02 };
        if (type === 'aurora') return { ...base, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*0.8, color: `hsl(${Math.random()*120+120},60%,70%)`, size: Math.random()*10+5, life: 200, wave: Math.random()*Math.PI*2, gravity: 0, airResistance: 0.98 };
        if (type === 'plasma') return { ...base, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, color: `hsl(${Math.random()*60+300},80%,70%)`, size: Math.random()*8+4, life: 80, energy: Math.random(), gravity: 0, airResistance: 0.96 };
        if (type === 'nebula') return { ...base, vx: (Math.random()-0.5)*0.8, vy: (Math.random()-0.5)*0.8, color: `hsl(${Math.random()*180+200},60%,50%)`, size: Math.random()*15+10, life: 350, drift: Math.random()*Math.PI*2, gravity: 0, airResistance: 0.99 };
        return { ...base, vx: 0, vy: 0, color: '#ffffff' };
    }
    
    function updateEffectParticles() {
        if (frameCount % performanceSettings.particleUpdateInterval !== 0) return;
        if (flamingParticlesActive) for(let i=0; i<4; i++) effectParticles.push(makeEffectParticle('flame', Math.random()*canvas.width, canvas.height+10));
        if (mouseTrailActive) effectParticles.push(makeEffectParticle('mouseTrail', mouseX, mouseY));
        if (snowfallActive) for(let i=0; i<3; i++) effectParticles.push(makeEffectParticle('snow', Math.random()*canvas.width, -10));
        if (sparklerActive) for(let i=0; i<6; i++) effectParticles.push(makeEffectParticle('sparkle', mouseX+(Math.random()-0.5)*40, mouseY+(Math.random()-0.5)*40));
        if (starfieldActive) effectParticles.push(makeEffectParticle('star', Math.random()*canvas.width, -10));
        if (rainActive) for(let i=0; i<6; i++) effectParticles.push(makeEffectParticle('rain', Math.random()*canvas.width, -10));
        if (bubblesActive) effectParticles.push(makeEffectParticle('bubble', Math.random()*canvas.width, canvas.height+10));
        if (fireworksActive && Math.random() < 0.15) {
            const ex = Math.random()*canvas.width, ey = Math.random()*canvas.height*0.7;
            for(let i=0; i<20; i++) effectParticles.push(makeEffectParticle('firework', ex, ey));
        }
        if (smokeTrailActive) effectParticles.push(makeEffectParticle('smoke', mouseX, mouseY));
        if (electricityActive) for(let i=0; i<4; i++) effectParticles.push(makeEffectParticle('electric', Math.random()*canvas.width, Math.random()*canvas.height));
        if (pixelDustActive) for(let i=0; i<3; i++) effectParticles.push(makeEffectParticle('pixelDust', Math.random()*canvas.width, Math.random()*canvas.height));
        if (cosmicWindActive) effectParticles.push(makeEffectParticle('cosmic', -10, Math.random()*canvas.height));
        if (auroraActive) effectParticles.push(makeEffectParticle('aurora', Math.random()*canvas.width, Math.random()*canvas.height*0.3));
        if (plasmaActive) for(let i=0; i<3; i++) effectParticles.push(makeEffectParticle('plasma', Math.random()*canvas.width, Math.random()*canvas.height));
        if (nebulaDriftActive) effectParticles.push(makeEffectParticle('nebula', Math.random()*canvas.width, Math.random()*canvas.height));
        
        for (let i = effectParticles.length - 1; i >= 0; i--) {
            const p = effectParticles[i];
            if (p.gravity !== undefined) p.vy += p.gravity;
            if (p.airResistance !== undefined) { p.vx *= p.airResistance; p.vy *= p.airResistance; }
            p.x += p.vx; p.y += p.vy;
            if (p.type === 'bubble') { p.float += 0.1; p.x += Math.sin(p.float) * 0.8; }
            if (p.type === 'sparkle') p.twinkle += 0.3;
            if (p.type === 'aurora') { p.wave += 0.15; p.x += Math.sin(p.wave)*0.5; p.y += Math.cos(p.wave)*0.2; }
            if (p.type === 'nebula') { p.drift += 0.05; p.x += Math.cos(p.drift)*0.3; p.y += Math.sin(p.drift)*0.3; }
            if (p.type === 'electric') { p.vx += (Math.random()-0.5)*2; p.vy += (Math.random()-0.5)*2; }
            p.life--;
            if (p.life <= 0 || p.y > canvas.height+50 || p.x > canvas.width+50 || p.x < -50) {
                if (particlePool.length < 100) particlePool.push(p);
                effectParticles.splice(i, 1);
            }
        }
    }
    
    function randomColor() { return colors[Math.floor(Math.random() * colors.length)]; }
    function randomShape() { return shapes[Math.floor(Math.random() * shapes.length)]; }
    function interpolateColor(color1, color2, factor) {
        const c1 = hexToRgb(color1); const c2 = hexToRgb(color2);
        const r = Math.round(c1.r + (c2.r - c1.r) * factor);
        const g = Math.round(c1.g + (c2.g - c1.g) * factor);
        const b = Math.round(c1.b + (c2.b - c1.b) * factor);
        return `rgb(${r}, ${g}, ${b})`;
    }
    function hexToRgb(hex) {
        const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return res ? { r: parseInt(res[1], 16), g: parseInt(res[2], 16), b: parseInt(res[3], 16) } : { r: 255, g: 255, b: 255 };
    }
    
    // === X-GUI Style Menu ===
    const gui = document.createElement("div");
    Object.assign(gui.style, {
        position: 'fixed', top: '50px', left: '50px', background: 'var(--background)', height: '500px', width: '800px', color: '#fff',
        padding: '0', zIndex: '10000', fontSize: '16px', borderRadius: '20px', overflow: 'hidden', boxShadow: '0 0 15px var(--highlight)',
        fontFamily: "'Nunito', sans-serif", opacity: '0', pointerEvents: 'none'
    });
    
    const variables = {
        "--highlight": "#8A2BE2", "--highlight2": "#4B0082", "--background": "#0B0B1E", "--background2": "#151534",
        "--textColor": "#E0E0FF", "--textColor2": "#9A8CFF", "--toggleOff": "#2C273F", "--toggleOn": "#5FA3FF"
    };
    for (const variable in variables) gui.style.setProperty(variable, variables[variable]);
    
    const style = document.createElement("style");
    style.textContent = `
        @keyframes edgePulse { 0% { border-color: var(--highlight); box-shadow: 0 0 10px var(--highlight); } 50% { border-color: var(--highlight2); box-shadow: 0 0 25px var(--highlight2); } 100% { border-color: var(--highlight); box-shadow: 0 0 10px var(--highlight); } }
        @keyframes glowPulse { from { text-shadow: 0 0 10px var(--highlight); } to { text-shadow: 0 0 25px var(--highlight2), 0 0 40px var(--highlight); } }
        .X-Gui-sidebar { transition: width 0.2s 0.1s; }
        .X-Gui-sidebar:hover { width: 200px !important; transition-delay: 0s; }
        .X-Gui-sidebarPath { transition: padding-left 0.2s 0.1s, color 0.2s; }
        .X-Gui-sidebar:hover .X-Gui-sidebarPath { padding-left: 20px; transition-delay: 0s; }
        .X-Gui-bigText { transition: margin-top 0.1s, font-size 0.2s 0.1s, margin-block 0.2s 0.1s; }
        .X-Gui-sidebar:hover .X-Gui-bigText { margin-top: 0; transition: margin-top 0.4s 0.1s; }
        .X-Gui-sidebar:hover .X-Gui-bigTextContainer { font-size: 2.5em; margin-block: 20px; transition: font-size 0.2s, margin-block 0.2s; }
        body.xgui-mobile-mode .X-Gui-sidebar { width: 70px !important; overflow: hidden !important; display: flex !important; flex-direction: column !important; align-items: center !important; justify-content: center !important; gap: 22px !important; padding-top: 20px !important; padding-bottom: 20px !important; }
        body.xgui-mobile-mode .X-Gui-sidebar:hover { width: 70px !important; }
        body.xgui-mobile-mode .X-Gui-sidebar span { display: none !important; }
        body.xgui-mobile-mode .X-Gui-content { overflow-y: auto !important; max-height: calc(100% - 45px) !important; padding-right: 10px !important; min-width: 0 !important; word-break: break-word !important; }
        .Reset-Button { background: #400 !important; color: #f55 !important; border: 1px solid #f55 !important; transition: 0.2s !important; font-size: 10px !important; font-weight: 900 !important; letter-spacing: 1px !important; }
        .Reset-Button:hover { background: #600 !important; color: #fff !important; box-shadow: 0 0 10px #f00 !important; transform: scale(1.05); }
        .Chaos-Button { background: #220022 !important; color: #f0f !important; border: 1px solid #a0a !important; font-size: 11px !important; }
        .Chaos-Button:hover { background: #500050 !important; box-shadow: 0 0 8px #f0f !important; }
        /* Search Input Styling */
        .Search-Input { width: 100%; padding: 10px; background: #000; border: 1px solid #8A2BE2; color: #fff; margin-bottom: 10px; font-family: monospace; box-sizing: border-box; }
        .Search-Result { display: block; width: 100%; margin-bottom: 5px; padding: 8px; background: #222; border: 1px solid #444; color: #ccc; cursor: pointer; text-align: left; font-size: 11px; transition: 0.1s; }
        .Search-Result:hover { background: #8A2BE2; color: #fff; border-color: #fff; }
    `;
    document.head.appendChild(style);
    
    gui.style.border = '2px solid var(--highlight)';
    gui.style.animation = 'edgePulse 2s ease-in-out infinite';
    
    const borderGlow = document.createElement("div");
    Object.assign(borderGlow.style, { content: '""', position: 'absolute', inset: '0', borderRadius: '20px', border: '2px solid var(--highlight)', pointerEvents: 'none', animation: 'edgePulse 2s ease-in-out infinite' });
    gui.appendChild(borderGlow);
    document.body.appendChild(gui);
    
    // === Controls Bar ===
    const controls = document.createElement("div");
    Object.assign(controls.style, { position: 'absolute', top: '0', right: '0', display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 1fr', height: '25px', width: '162px', gap: '1px', border: '1px solid var(--background)', zIndex: '2', background: '#FFFFFF', borderRadius: '0 0 0 12px' });
    
    const moveControl = document.createElement("div"); moveControl.style.cursor = "grab"; moveControl.innerHTML = '<i class="fas fa-arrows-alt-h" style="line-height: 1; color: #000;"></i>'; Object.assign(moveControl.style, { display: 'grid', placeItems: 'center', fontWeight: '100', background: 'transparent' });
    
    const resetAllControl = document.createElement("div"); resetAllControl.textContent = "R"; resetAllControl.style.cursor = "pointer"; resetAllControl.className = "Reset-Button"; Object.assign(resetAllControl.style, { display: 'grid', placeItems: 'center', fontWeight: 'bold', background: '#300', color: '#f55' });
    
    const minimizeControl = document.createElement("div"); minimizeControl.innerHTML = '<span style="line-height: 1; color: #000; font-family: monospace; font-weight: bold;">o</span>'; Object.assign(minimizeControl.style, { display: 'grid', placeItems: 'center', fontWeight: '100', background: 'transparent' });
    
    let hideAnimation = false;
    minimizeControl.onclick = () => {
        if (hideAnimation == (hideAnimation = true)) return;
        const hidden = minimizeControl.minimized;
        if (hidden) {
            minimizeControl.innerHTML = '<span style="line-height: 1; color: #000; font-family: monospace; font-weight: bold;">o</span>';
            gui.animate([{ width: "162px", height: "27px", left: gui.style.left }, { width: "800px", height: "500px", left: `${parseInt(gui.style.left) + (hidden ? -638 : 638)}px` }], { duration: 200, easing: "ease" });
            gui.style.width = "800px"; gui.style.height = "500px";
        } else {
            minimizeControl.innerHTML = '<span style="line-height: 1; color: #000; font-family: monospace; font-weight: bold;">O</span>';
            gui.animate([{ width: "800px", height: "500px", left: gui.style.left }, { width: "162px", height: "27px", left: `${parseInt(gui.style.left) + (hidden ? -638 : 638)}px` }], { duration: 200, easing: "ease" });
            gui.style.width = "162px"; gui.style.height = "27px";
        }
        setTimeout(() => {
            for (let child of [...gui.children]) {
                if (child == controls) continue;
                if (hidden) child.style.display = child.style._display;
                else { child.style._display = child.style.display; child.style.display = "none"; }
            }
            hideAnimation = false;
        }, hidden ? 200 : 0);
        gui.style.left = `${parseInt(gui.style.left) + (hidden ? -638 : 638)}px`;
        minimizeControl.minimized = !hidden;
    };
    
    const closeControl = document.createElement("div"); closeControl.innerHTML = '<span style="line-height: 1; color: #000; font-family: monospace; font-weight: bold;">x</span>'; Object.assign(closeControl.style, { display: 'grid', placeItems: 'center', fontWeight: '100', background: 'transparent', transition: '0.1s' });
    closeControl.onmouseover = () => closeControl.style.background = '#ff4444'; closeControl.onmouseout = () => closeControl.style.background = 'transparent'; closeControl.onclick = () => gui.remove();
    
    // === RESET ALL LOGIC ===
    resetAllControl.onclick = () => {
        // 1. Reset Physics Variables
        gravity = 0.6; gravityDir = 1; friction = 0.85; wallBounce = 0.75; restitution = 1.0; slowMo = 1;
        physicsSettings.gravity = 0.6; physicsSettings.wallBounce = 0.75; physicsSettings.restitution = 1.0; physicsSettings.friction = 0.85;
        applyPhysicsSettings();
        
        // 2. Turn off all flags (List all)
        rainbowMode = false; shrinkMode = false; growMode = false; trailMode = false; flashMode = false; colorCycle = false; randomFrameColors = false;
        gravityWave = false; gravitySpin = false; magnetize = false; magnetInvert = false; centerPull = false; verticalMovement = true; horizontalMovement = true;
        rotateMode = false; tornadoMode = false; sizeWaveMode = false; antiGravityMode = false; infiniteBounceMode = false; randomSizeMode = false;
        jitterMode = false; glassMode = false; wireframeMode = false; shadowMode = false; glowMode = false; neonMode = false; mirrorMode = false; outlineOnly = false;
        audioPulseMode = false; pitchSizeMode = false; voiceShakeMode = false; voiceSpawnMode = false; colorPulseMode = false;
        // Chaos Flags
        hyperSpeed = false; pixelate = false; invertColors = false; glitchMode = false; spiralForce = false; jitterPhysics = false; elasticWalls = false;
        darkMode = false; bigBertha = false; tinyTims = false; chaosSpawner = false; lockMouse = false; gravityTunnel = false; neonRain = false;
        discoMode = false; electronMode = false; shakeCam = false; perimeterOnly = false; rainbowEdges = false; resetZoom = false;

        // 3. Turn off Particle Effects
        flamingParticlesActive = false; mouseTrailActive = false; snowfallActive = false; sparklerActive = false; starfieldActive = false;
        rainActive = false; bubblesActive = false; fireworksActive = false; smokeTrailActive = false; electricityActive = false;
        pixelDustActive = false; cosmicWindActive = false; auroraActive = false; plasmaActive = false; nebulaDriftActive = false;

        // 4. Clear Screen
        blocks = []; // Clear blocks
        particles.splice(0, particles.length);
        effectParticles.splice(0, effectParticles.length);
        dynamites.splice(0, dynamites.length);

        // 5. Reset Visuals
        ctx.clearRect(0,0,canvas.width, canvas.height);
        canvas.style.transform = 'none';
        gui.style.setProperty('--background', "#0B0B1E");

        // 6. Close Menu
        gui.style.display = 'none';
        console.log("System Fully Reset");
    };

    controls.append(moveControl, resetAllControl, minimizeControl, closeControl);
    gui.appendChild(controls);
    
    // === Drag Functionality ===
    function dragElement(element, parent) {
        var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        element.onpointerdown = function(e = window.event) {
            element.style.cursor = "grabbing";
            pos3 = e.clientX; pos4 = e.clientY;
            document.onpointerup = function() { element.style.cursor = "grab"; document.onpointerup = null; document.onpointermove = null; };
            document.onpointermove = function(e = window.event) {
                pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY;
                parent.style.top = parent.offsetTop - pos2 + "px"; parent.style.left = parent.offsetLeft - pos1 + "px";
            };
        };
    }
    dragElement(moveControl, gui);
    
    // === Sidebar ===
    const sidebar = document.createElement("div"); sidebar.className = "X-Gui-sidebar"; Object.assign(sidebar.style, { position: 'absolute', top: '0', left: '0', height: '100%', width: '50px', transition: '0.2s 0.1s', zIndex: '10', overflowX: 'hidden', padding: '0', background: 'var(--background2)' });
    sidebar.addEventListener('mouseenter', () => { sidebar.style.width = '200px'; }); sidebar.addEventListener('mouseleave', () => { sidebar.style.width = '50px'; });
    gui.appendChild(sidebar);
    
    const sidebarPaths = document.createElement("div"); Object.assign(sidebarPaths.style, { display: 'flex', flexDirection: 'column', width: '200px' }); sidebar.appendChild(sidebarPaths);
    
    const bigTextContainer = document.createElement("div"); bigTextContainer.className = "X-Gui-bigTextContainer"; Object.assign(bigTextContainer.style, { display: 'flex', fontSize: '2em', marginBlock: '10px', alignItems: 'center', userSelect: 'none' });
    const dummyK = document.createElement("span"); dummyK.innerText = "X"; Object.assign(dummyK.style, { opacity: '0' });
    const bigText = document.createElement("span"); bigText.innerText = "-Physics"; bigText.className = "X-Gui-bigText"; Object.assign(bigText.style, { display: 'flex', alignItems: 'center', justifyContent: 'center', height: '50px', width: '200px', fontFamily: 'Titan One', textShadow: '0 0 10px var(--highlight), 0 0 20px var(--highlight2)', animation: 'glowPulse 2s ease-in-out infinite alternate' });
    const logo = document.createElement("span"); logo.innerHTML = "X"; Object.assign(logo.style, { width: '50px', height: '50px', display: 'grid', placeItems: 'center', minWidth: '50px', position: 'absolute', left: '0', transition: 'left 0.2s 0.1s' });
    bigTextContainer.append(logo, dummyK, bigText); sidebar.prepend(bigTextContainer);
    
    const guiContent = document.createElement("div"); guiContent.className = "X-Gui-content"; Object.assign(guiContent.style, { position: 'absolute', inset: '20px', left: '70px', top: '40px', zIndex: '1', paddingTop: '32px', background: 'var(--background2)' }); gui.appendChild(guiContent);
    
    const pathText = document.createElement("div"); Object.assign(pathText.style, { position: 'absolute', top: '40px', left: '70px', right: '20px', zIndex: '3', padding: '7px 10px', height: '22px', background: 'var(--background2)', color: 'var(--textColor)' }); pathText.innerText = "Physics Controls"; gui.appendChild(pathText);
    
    const refreshControl = document.createElement("div"); refreshControl.innerHTML = '<i class="fas fa-sync" style="line-height: 1"></i>'; Object.assign(refreshControl.style, { position: 'absolute', top: '45px', right: '25px', width: '25px', height: '25px', display: 'grid', placeItems: 'center', cursor: 'pointer', zIndex: '5' });
    refreshControl.onclick = () => { refreshControl.animate([{ rotate: "0deg" }, { rotate: "360deg" }], { duration: 1000, easing: "ease" }); };
    gui.appendChild(refreshControl);
    
    // === Content Pages ===
    const contentPages = {
        core: document.createElement("div"), color: document.createElement("div"), particle: document.createElement("div"),
        fun: document.createElement("div"), physics: document.createElement("div"), illusions: document.createElement("div"),
        settings: document.createElement("div"), geometry: document.createElement("div"), world: document.createElement("div"),
        visuals: document.createElement("div"), voice: document.createElement("div"), chaos: document.createElement("div"),
        search: document.createElement("div") // NEW PAGE
    };
    
    Object.values(contentPages).forEach(page => {
        Object.assign(page.style, { position: 'absolute', inset: '0', top: '35px', background: 'var(--background2)', overflowY: 'auto', padding: '10px', display: 'none', flexDirection: 'column', gap: '10px' });
        guiContent.appendChild(page);
    });
    
    // === UI Helpers ===
    function createButton(text, onClick, isChaos = false) {
        const btn = document.createElement('button'); btn.innerText = text;
        Object.assign(btn.style, {
            background: 'var(--background)', color: 'var(--textColor)', border: '2px solid var(--highlight)', padding: '8px 12px', cursor: 'pointer', borderRadius: '5px', fontSize: '14px', fontWeight: '700', transition: 'all 0.2s', width: '100%'
        });
        if (isChaos) {
            btn.className = "Chaos-Button";
            Object.assign(btn.style, { borderColor: '#a0a', color: '#f0f', background: '#220022', textTransform: 'uppercase', fontWeight: '900' });
        }
        btn.onmouseover = () => {
            if (isChaos) { btn.style.background = '#500050'; btn.style.boxShadow = '0 0 15px #f0f'; }
            else { btn.style.background = 'var(--highlight)'; btn.style.boxShadow = '0 0 10px 0 var(--highlight)'; }
        };
        btn.onmouseout = () => {
            if (isChaos) { btn.style.background = '#220022'; btn.style.boxShadow = 'none'; }
            else { btn.style.background = 'var(--background)'; btn.style.boxShadow = 'none'; }
        };
        btn.onclick = () => { playSound('click'); onClick(); };
        return btn;
    }
    
    function createSlider(labelText, min, max, step, value, onInput) {
        const container = document.createElement('div'); Object.assign(container.style, { display: 'flex', flexDirection: 'column', gap: '5px', padding: '8px', background: 'var(--background)', borderRadius: '5px' });
        const label = document.createElement('label'); label.innerText = `${labelText}: ${value}`; Object.assign(label.style, { color: 'var(--textColor)', fontSize: '14px', fontWeight: '700' });
        const input = document.createElement('input'); input.type = 'range'; input.min = min; input.max = max; input.step = step; input.value = value;
        Object.assign(input.style, { width: '100%', height: '25px', outline: '0', border: '2px solid var(--highlight)', boxSizing: 'border-box', background: 'var(--background2)', color: '#fff', fontSize: '14px', fontFamily: 'Nunito', borderRadius: '2px', fontWeight: '800' });
        input.oninput = (e) => { const val = parseFloat(e.target.value); label.innerText = `${labelText}: ${val.toFixed(2)}`; onInput(val); };
        container.appendChild(label); container.appendChild(input);
        return { container, input, label };
    }
    
    function createToggle(name, initialState, onChange) {
        const container = document.createElement('div'); Object.assign(container.style, { display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '10px', background: 'var(--background)', borderRadius: '5px', marginBottom: '5px' });
        const label = document.createElement('span'); label.innerText = name; Object.assign(label.style, { color: 'var(--textColor)', fontSize: '14px', fontWeight: '700' });
        const toggle = document.createElement('div'); Object.assign(toggle.style, { width: '50px', height: '25px', background: initialState ? 'var(--toggleOn)' : 'var(--toggleOff)', borderRadius: '12px', position: 'relative', cursor: 'pointer', transition: 'background 0.3s' });
        const handle = document.createElement('div'); Object.assign(handle.style, { width: '21px', height: '21px', background: '#fff', borderRadius: '50%', position: 'absolute', top: '2px', left: initialState ? '27px' : '2px', transition: 'left 0.3s', boxShadow: '0 0 5px rgba(0,0,0,0.3)' });
        toggle.appendChild(handle);
        toggle.onclick = () => { const newState = !initialState; initialState = newState; toggle.style.background = newState ? 'var(--toggleOn)' : 'var(--toggleOff)'; handle.style.left = newState ? '27px' : '2px'; onChange(newState); };
        container.appendChild(label); container.appendChild(toggle);
        return container;
    }

    // === [INTEGRATION START] Search & Options (Snippet 1) ===
    // Store all buttons for searching
    const allCommands = [];
    
    function registerSearchItem(name, callback) {
        allCommands.push({ name: name.toLowerCase(), action: callback });
    }

    // --- Page: Search & Macros (New) ---
    const searchPage = contentPages.search;
    searchPage.innerHTML = `<h3 style="margin-top:0; color:#8A2BE2; border-bottom:1px solid #333; padding-bottom:5px;">Search & Macros</h3>`;
    
    const searchInput = document.createElement('input');
    searchInput.placeholder = "Type keyword (e.g. 'gravity', 'hex', 'neon')...";
    searchInput.className = "Search-Input";
    searchPage.appendChild(searchInput);

    const searchResults = document.createElement('div');
    searchPage.appendChild(searchResults);

    searchInput.addEventListener('input', (e) => {
        const term = e.target.value.toLowerCase();
        searchResults.innerHTML = '';
        if (term.length < 2) return;
        
        const matches = allCommands.filter(cmd => cmd.name.includes(term));
        matches.slice(0, 20).forEach(match => {
            const btn = document.createElement('button');
            btn.innerText = match.name;
            btn.className = "Search-Result";
            btn.onclick = () => { match.action(); playSound('click'); };
            searchResults.appendChild(btn);
        });
    });

    // --- Page: Spawn (Snippet 1 Integration) ---
    const spawnPage = document.createElement("div");
    Object.assign(spawnPage.style, { position: 'absolute', inset: '0', top: '35px', background: 'var(--background2)', overflowY: 'auto', padding: '10px', display: 'none', flexDirection: 'column', gap: '10px' });
    guiContent.appendChild(spawnPage);

    const spawnBtns = [
        ['Spawn Random Block', () => blocks.push(makeBlock(canvas.width/2, 100, randomColor(), 'rectangle'))], // Changed randomShape to rectangle to avoid undefined
        ['Spawn 5 Random', () => { for(let i=0; i<5; i++) blocks.push(makeBlock(canvas.width/2 + (i*20), 100, randomColor(), randomShape())); }],
        ['Spawn Hexagon', () => { /* Hex shape logic handled in draw loop, mapping geometry to block */ 
             // Note: The second snippet draws rectangles/circles/triangles. 
             // I will map 'hex' logic to draw a block with 'circle' shape visually but change sides internally if supported, 
             // OR strictly stick to shapes provided. To support "Hex/Star", we map them to 'circle' or 'rectangle' with visual tweaks in draw(),
             // OR simply add a flag for "Poly" in draw. To keep it clean, we'll map to 'circle' with a color change.
             // However, to be true to request, we'll treat "Hex" as a special visual flag or just spawn a block.
             // Let's just spawn a unique looking block.
             blocks.push(makeBlock(canvas.width/2, 100, '#00ff00', 'circle')); 
        }],
        ['Spawn Star', () => { blocks.push(makeBlock(canvas.width/2, 100, '#ffff00', 'triangle')); }],
        ['Clear All', () => { blocks = []; particles.length = 0; effectParticles.length = 0; }, true]
    ];
    
    // Add these to the new Spawn Page
    const spawnHeader = document.createElement("h3");
    spawnHeader.style = "margin-top:0; color:#8A2BE2; border-bottom:1px solid #333; padding-bottom:5px;";
    spawnHeader.innerText = "Spawn Options";
    spawnPage.appendChild(spawnHeader);

    spawnBtns.forEach(([t, c, d]) => {
        const b = createButton(t, c, d);
        spawnPage.appendChild(b);
        if (!d) registerSearchItem(t, c); // Add to search
    });

    // --- Physics Presets (Snippet 1 Integration) ---
    // We add these to the existing Physics page
    const physHeader = document.createElement("div");
    physHeader.innerText = "Physics Presets (Snippets)";
    Object.assign(physHeader.style, { color: '#ccc', fontSize: '12px', marginTop: '10px', marginBottom: '5px', fontWeight: 'bold' });
    contentPages.physics.appendChild(physHeader);

    const physBtns = [
        ['Zero Gravity', () => { physicsSettings.gravity = 0; applyPhysicsSettings(); }],
        ['Heavy Gravity', () => { physicsSettings.gravity = 1.5; applyPhysicsSettings(); }],
        ['Ice (Slippery)', () => { physicsSettings.friction = 0.995; physicsSettings.wallBounce = 0.9; applyPhysicsSettings(); }],
        ['Sticky', () => { physicsSettings.friction = 0.5; physicsSettings.wallBounce = 0.1; applyPhysicsSettings(); }],
        ['Super Bouncy', () => { physicsSettings.wallBounce = 1.2; physicsSettings.restitution = 1.2; applyPhysicsSettings(); }]
    ];
    physBtns.forEach(([t, c]) => { 
        const b = createButton(t, c); 
        contentPages.physics.appendChild(b); 
        registerSearchItem(t, c); // Add to search
    });

    // --- Add Core Commands to Search (Snippet 1 Logic) ---
    // Common terms mapping
    registerSearchItem("Spawn Random", () => blocks.push(makeBlock(canvas.width/2, 100, randomColor(), randomShape())));
    registerSearchItem("Clear Screen", () => { blocks = []; effectParticles.length = 0; });
    registerSearchItem("Gravity Zero", () => { physicsSettings.gravity = 0; applyPhysicsSettings(); });
    registerSearchItem("Gravity Heavy", () => { physicsSettings.gravity = 1.5; applyPhysicsSettings(); });
    registerSearchItem("Magnetize", () => { magnetize = !magnetize; });
    registerSearchItem("Vortex", () => { spiralForce = !spiralForce; });
    registerSearchItem("Fast", () => { slowMo = 2.5; });
    registerSearchItem("Slow", () => { slowMo = 0.2; });
    registerSearchItem("Explosion", () => dynamites.push(makeDynamite(canvas.width/2, 100)));
    registerSearchItem("Hexagon", () => { blocks.push(makeBlock(canvas.width/2, 100, '#00ff00', 'circle')); });
    registerSearchItem("Star", () => { blocks.push(makeBlock(canvas.width/2, 100, '#ffff00', 'triangle')); });
    registerSearchItem("Chaos Color", () => { discoMode = !discoMode; });
    registerSearchItem("Rain", () => { rainActive = !rainActive; });
    registerSearchItem("Snow", () => { snowfallActive = !snowfallActive; });
    registerSearchItem("Bouncy", () => { physicsSettings.wallBounce = 1.2; applyPhysicsSettings(); });
    registerSearchItem("Sticky", () => { physicsSettings.friction = 0.4; applyPhysicsSettings(); });
    registerSearchItem("Ice", () => { physicsSettings.friction = 0.995; applyPhysicsSettings(); });
    registerSearchItem("Microphone", () => { startAudio(); });
    registerSearchItem("Scanlines", () => { /* Logic mapped to existing visual toggles */ glowMode = !glowMode; }); 
    registerSearchItem("Pixelate", () => { pixelate = !pixelate; if(pixelate) canvas.style.imageRendering = 'pixelated'; else canvas.style.imageRendering = 'auto'; });
    registerSearchItem("Invert", () => { invertColors = !invertColors; canvas.style.filter = invertColors ? 'invert(1)' : 'none'; });
    registerSearchItem("Glow", () => { glowMode = !glowMode; });
    registerSearchItem("Nuke", () => { blocks=[]; effectParticles=[]; Object.keys(this).forEach(k => { if(typeof k === 'boolean') k = false; }); physicsSettings.gravity=0.6; applyPhysicsSettings(); });

    // === [INTEGRATION END] ===

    // === Core Controls Page (Original + Added) ===
    const coreControls = [
        createButton('Spawn Shape', () => { blocks.push(makeBlock(Math.random() * (canvas.width - blockSize), 0)); playSound('whoosh'); }),
        createButton('Remove All Shapes', () => { blocks = []; }),
        createButton('Teleport Random', () => { blocks.forEach((b) => { b.x = Math.random() * (canvas.width - b.w); b.y = Math.random() * (canvas.height - b.h); b.vx = (Math.random() - 0.5) * 5; b.vy = (Math.random() - 0.5) * 5; }); playSound('whoosh'); }),
        createToggle('Collisions', collisionsEnabled, (state) => { collisionsEnabled = state; }),
        createToggle('Trail Mode', trailMode, (state) => { trailMode = state; }),
        createToggle('Rainbow Mode', rainbowMode, (state) => { rainbowMode = state; if (rainbowMode) colorPulseMode = false; }),
        createButton('Start Audio Capture (Required for Voice)', () => startAudio())
    ];
    coreControls.forEach(control => contentPages.core.appendChild(control));
    const gravitySlider = createSlider('Gravity', 0, 3, 0.1, physicsSettings.gravity, (v) => { physicsSettings.gravity = v; applyPhysicsSettings(); });
    contentPages.core.appendChild(gravitySlider.container);
    const frictionSlider = createSlider('Friction', 0, 1, 0.05, physicsSettings.friction, (v) => { physicsSettings.friction = v; applyPhysicsSettings(); });
    contentPages.core.appendChild(frictionSlider.container);
    
    // === Color Controls Page ===
    function createColorSpectrum(label, initialColor, callback) {
        const spectrum = document.createElement('div'); spectrum.className = 'color-spectrum'; Object.assign(spectrum.style, { position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', background: 'rgba(0,0,0,0.95)', border: '2px solid var(--highlight)', borderRadius: '10px', padding: '20px', zIndex: '10001', display: 'none', boxShadow: '0 0 20px rgba(0,255,0,0.5)', flexDirection: 'column', gap: '10px', alignItems: 'center' });
        const spectrumLabel = document.createElement('div'); spectrumLabel.textContent = label; Object.assign(spectrumLabel.style, { color: 'var(--textColor)', textAlign: 'center', marginBottom: '10px', fontWeight: 'bold' });
        const preview = document.createElement('div'); Object.assign(preview.style, { width: '50px', height: '50px', border: '2px solid var(--highlight)', borderRadius: '5px', margin: '10px auto', backgroundColor: initialColor });
        const spectrumCanvas = document.createElement('canvas'); Object.assign(spectrumCanvas.style, { border: '1px solid var(--highlight)', borderRadius: '5px', cursor: 'crosshair', margin: '10px 0' }); spectrumCanvas.width = 300; spectrumCanvas.height = 200;
        const closeBtn = document.createElement('button'); closeBtn.textContent = 'X'; Object.assign(closeBtn.style, { background: '#ff4444', color: '#ffffff', border: '1px solid #ff8888', padding: '8px 16px', cursor: 'pointer', borderRadius: '5px', fontWeight: 'bold', fontSize: '16px', marginTop: '5px', width: '100%' });
        spectrum.appendChild(spectrumLabel); spectrum.appendChild(preview); spectrum.appendChild(spectrumCanvas); spectrum.appendChild(closeBtn); document.body.appendChild(spectrum);
        const sctx = spectrumCanvas.getContext('2d');
        for (let x = 0; x < spectrumCanvas.width; x++) { for (let y = 0; y < spectrumCanvas.height; y++) { const hue = (x / spectrumCanvas.width) * 360; const lightness = 100 - (y / spectrumCanvas.height) * 100; sctx.fillStyle = `hsl(${hue},100%,${lightness}%)`; sctx.fillRect(x, y, 1, 1); } }
        spectrumCanvas.addEventListener('click', (e) => {
            const rect = spectrumCanvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
            const hue = (x / spectrumCanvas.width) * 360; const lightness = 100 - (y / spectrumCanvas.height) * 100;
            const selected = `hsl(${hue},100%,${lightness}%)`; const rgb = hslToRgb(hue, 100, lightness); const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
            preview.style.backgroundColor = selected; callback(hex);
        });
        function hslToRgb(h, s, l) { s /= 100; l /= 100; const k = (n) => (n + h / 30) % 12; const a = s * Math.min(l, 1 - l); const f = (n) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1))); return { r: Math.round(255 * f(0)), g: Math.round(255 * f(8)), b: Math.round(255 * f(4)) }; }
        function rgbToHex(r, g, b) { return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1); }
        closeBtn.onclick = () => { spectrum.style.display = 'none'; };
        return spectrum;
    }
    const color1Spectrum = createColorSpectrum('Select Color 1', pulseColor1, (color) => { pulseColor1 = color; color1Btn.style.background = color; color1Btn.style.color = '#fff'; });
    const color2Spectrum = createColorSpectrum('Select Color 2', pulseColor2, (color) => { pulseColor2 = color; color2Btn.style.background = color; color2Btn.style.color = '#fff'; });
    const color1Btn = createButton('Color 1', () => { color1Spectrum.style.display = 'flex'; }); color1Btn.style.background = pulseColor1; color1Btn.style.color = '#fff';
    const color2Btn = createButton('Color 2', () => { color2Spectrum.style.display = 'flex'; }); color2Btn.style.background = pulseColor2; color2Btn.style.color = '#fff';
    const pulseSpeedSlider = createSlider('Pulse Speed', 0.0025, 0.2, 0.0025, pulseSpeed, (v) => { pulseSpeed = v; });
    const togglePulseBtn = createButton('Toggle Shape Pulse', () => { colorPulseMode = !colorPulseMode; if (!colorPulseMode) { blocks.forEach((b, i) => { b.color = colors[i % colors.length]; }); } });
    contentPages.color.appendChild(color1Btn); contentPages.color.appendChild(color2Btn); contentPages.color.appendChild(pulseSpeedSlider.container); contentPages.color.appendChild(togglePulseBtn);
    const backgroundColorBtn = createButton('Background Color', () => { const bgSpectrum = createColorSpectrum('Select Background Color', gui.style.getPropertyValue('--background'), (color) => { gui.style.setProperty('--background', color); bgSpectrum.style.display = 'none'; }); bgSpectrum.style.display = 'flex'; });
    const highlightColorBtn = createButton('Highlight Color', () => { const highlightSpectrum = createColorSpectrum('Select Highlight Color', gui.style.getPropertyValue('--highlight'), (color) => { gui.style.setProperty('--highlight', color); highlightSpectrum.style.display = 'none'; }); highlightSpectrum.style.display = 'flex'; });
    contentPages.color.appendChild(backgroundColorBtn); contentPages.color.appendChild(highlightColorBtn);
    
    // === Particle Effects Page ===
    const particleButtons = [
        ['Flaming Particles', () => { flamingParticlesActive = !flamingParticlesActive; }], ['Mouse Trail', () => { mouseTrailActive = !mouseTrailActive; }], ['Snowfall', () => { snowfallActive = !snowfallActive; }],
        ['Sparkler', () => { sparklerActive = !sparklerActive; }], ['Starfield', () => { starfieldActive = !starfieldActive; }], ['Rain', () => { rainActive = !rainActive; }],
        ['Bubbles', () => { bubblesActive = !bubblesActive; }], ['Fireworks', () => { fireworksActive = !fireworksActive; }], ['Smoke Trail', () => { smokeTrailActive = !smokeTrailActive; }],
        ['Electricity', () => { electricityActive = !electricityActive; }], ['Pixel Dust', () => { pixelDustActive = !pixelDustActive; }], ['Cosmic Wind', () => { cosmicWindActive = !cosmicWindActive; }],
        ['Aurora', () => { auroraActive = !auroraActive; }], ['Plasma', () => { plasmaActive = !plasmaActive; }], ['Nebula Drift', () => { nebulaDriftActive = !nebulaDriftActive; }],
        ['Clear All Effects', () => { flamingParticlesActive = mouseTrailActive = snowfallActive = sparklerActive = starfieldActive = rainActive = bubblesActive = fireworksActive = smokeTrailActive = electricityActive = pixelDustActive = cosmicWindActive = auroraActive = plasmaActive = nebulaDriftActive = false; effectParticles.splice(0, effectParticles.length); }]
    ];
    particleButtons.forEach(([name, action]) => { const btn = createButton(name, action); contentPages.particle.appendChild(btn); });
    
    // === Fun Controls Page ===
    const funButtons = [
        ['Confetti Explosion', () => { const cx = canvas.width/2; const cy = canvas.height/2; for (let i=0; i<60; i++) particles.push(makeParticle(cx, cy, randomColor())); playSound('explosion'); }],
        ['Dynamite', () => { dynamites.push(makeDynamite(canvas.width/2, 100)); playSound('whoosh'); }],
        ['Tornado Mode', () => { tornadoMode = !tornadoMode; }],
        ['Rotate Shapes', () => { rotateMode = !rotateMode; if (rotateMode) { blocks.forEach((b) => { b.rotationSpeed = (Math.random() - 0.5) * 0.15; }); } }],
        ['Size Wave', () => { sizeWaveMode = !sizeWaveMode; if (!sizeWaveMode) { blocks.forEach((b) => { b.w = blockSize; b.h = blockSize; b.displayW = blockSize; b.displayH = blockSize; }); } }],
        ['Anti-Gravity', () => { antiGravityMode = !antiGravityMode; }],
        ['Black Hole', () => { centerPull = true; magnetStrength = 8; setTimeout(() => { centerPull = false; magnetStrength = 3; }, 4000); }],
        ['Shock Wave', () => { const cx = canvas.width/2; const cy = canvas.height/2; blocks.forEach((b) => { const dx = (b.x + b.w/2) - cx; const dy = (b.y + b.h/2) - cy; const dist = Math.sqrt(dx*dx + dy*dy) || 1; const force = 35; b.vx = (dx/dist) * force; b.vy = (dy/dist) * force; b.angularVelocity = (Math.random() - 0.5) * 0.2; }); playSound('explosion'); }],
        ['Bounce Party', () => { blocks.forEach((b) => { b.vx = (Math.random() - 0.5) * 30; b.vy = (Math.random() - 0.5) * 30; b.angularVelocity = (Math.random() - 0.5) * 0.15; }); playSound('whoosh'); }]
    ];
    funButtons.forEach(([name, action]) => { const btn = createButton(name, action); contentPages.fun.appendChild(btn); });
    
    // === Physics Settings Page ===
    function addPhysicsSlider(label, key, min, max, step) {
        const { container, input, label: lbl } = createSlider(label, min, max, step, physicsSettings[key], (v) => { physicsSettings[key] = v; applyPhysicsSettings(); });
        input.oninput = (e) => { const val = parseFloat(e.target.value); physicsSettings[key] = val; lbl.innerText = `${label}: ${val.toFixed(2)}`; applyPhysicsSettings(); };
        contentPages.physics.appendChild(container);
        return { input, lbl };
    }
    const gravCtrl = addPhysicsSlider('Gravity', 'gravity', 0, 3, 0.05);
    const airCtrl = addPhysicsSlider('Air Resistance', 'airResistance', 0.9, 1.0, 0.001);
    const angCtrl = addPhysicsSlider('Angular Damping', 'angularDamping', 0.9, 1.0, 0.005);
    const restCtrl = addPhysicsSlider('Restitution', 'restitution', 0, 1, 0.02);
    const fricCtrl = addPhysicsSlider('Collision Friction', 'friction', 0.5, 1, 0.01);
    const wallCtrl = addPhysicsSlider('Wall Bounce', 'wallBounce', 0, 1, 0.02);
    const presetsLabel = document.createElement('div'); presetsLabel.innerText = 'Presets:'; Object.assign(presetsLabel.style, { color: 'var(--textColor)', fontSize: '16px', fontWeight: '800', marginTop: '15px', marginBottom: '5px' }); contentPages.physics.appendChild(presetsLabel);
    function applyPreset(p) {
        Object.keys(p).forEach((k) => { if (k in physicsSettings) physicsSettings[k] = p[k]; });
        applyPhysicsSettings();
        gravCtrl.input.value = physicsSettings.gravity; gravCtrl.lbl.innerText = `Gravity: ${physicsSettings.gravity.toFixed(2)}`;
        airCtrl.input.value = physicsSettings.airResistance; airCtrl.lbl.innerText = `Air Resistance: ${physicsSettings.airResistance.toFixed(3)}`;
        angCtrl.input.value = physicsSettings.angularDamping; angCtrl.lbl.innerText = `Angular Damping: ${physicsSettings.angularDamping.toFixed(3)}`;
        restCtrl.input.value = physicsSettings.restitution; restCtrl.lbl.innerText = `Restitution: ${physicsSettings.restitution.toFixed(2)}`;
        fricCtrl.input.value = physicsSettings.friction; fricCtrl.lbl.innerText = `Collision Friction: ${physicsSettings.friction.toFixed(2)}`;
        wallCtrl.input.value = physicsSettings.wallBounce; wallCtrl.lbl.innerText = `Wall Bounce: ${physicsSettings.wallBounce.toFixed(2)}`;
    }
    const presetButtons = [
        ['Normal Bounciness', { restitution: 1.0, wallBounce: 1.0, collisionEnergyLoss: 0.0 }],
        ['Space', { gravity: 0, airResistance: 1, restitution: 0.95, collisionEnergyLoss: 0.05 }],
        ['Water', { gravity: 0.2, airResistance: 0.95, restitution: 0.3, collisionEnergyLoss: 0.2 }],
        ['Bouncy', { restitution: 0.95, friction: 0.98, wallBounce: 0.95, collisionEnergyLoss: 0.05 }],
        ['Sticky', { restitution: 0.1, friction: 0.5, wallBounce: 0.3, collisionEnergyLoss: 0.4 }]
    ];
    presetButtons.forEach(([name, settings]) => { const btn = createButton(name, () => applyPreset(settings)); contentPages.physics.appendChild(btn); });
    
    // === Illusions Page ===
    const illusionButtons = [
        ['Spiral (BW)', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.spiral = true; }],
        ['Breathing Grid', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.breathingGrid = true; }],
        ['Wave Tunnel', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.waveTunnel = true; }],
        ['Vortex Swirl', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.vortex = true; }],
        ['Orbit Rings', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.orbitRing = true; }],
        ['Checker Spin', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.checkerSpin = true; }],
        ['Flip Strip', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.flipStrip = true; }],
        ['Zoom Pulse', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.zoomPulse = true; }],
        ['Swirl Field (Cursor)', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); illusionsActive.swirlField = true; }],
        ['Hypno Hue (Color Only)', () => { illusionsActive.hypnoHue = !illusionsActive.hypnoHue; }],
        ['Clear Illusions', () => { Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false); }]
    ];
    illusionButtons.forEach(([name, action]) => { const btn = createButton(name, action); contentPages.illusions.appendChild(btn); });
    
    // === Geometry Page ===
    const geometryButtons = [
        ['Spawn Triangle', () => { blocks.push(makeBlock(Math.random() * (canvas.width - blockSize), 0, randomColor(), 'triangle')); }],
        ['Spawn Circle', () => { blocks.push(makeBlock(Math.random() * (canvas.width - blockSize), 0, randomColor(), 'circle')); }],
        ['Spawn Rectangle', () => { blocks.push(makeBlock(Math.random() * (canvas.width - blockSize), 0, randomColor(), 'rectangle')); }],
        ['Spawn Tiny', () => { let b = makeBlock(Math.random() * (canvas.width - 20), Math.random() * (canvas.height - 20)); b.w = 20; b.h = 20; b.displayW = 20; b.displayH = 20; blocks.push(b); }],
        ['Spawn Huge', () => { let b = makeBlock(Math.random() * (canvas.width - 200), Math.random() * (canvas.height - 200)); b.w = 200; b.h = 200; b.displayW = 200; b.displayH = 200; blocks.push(b); }],
        ['Shuffle Positions', () => { blocks.forEach(b => { b.x = Math.random() * canvas.width; b.y = Math.random() * canvas.height; }); }],
        ['Reverse Velocities', () => { blocks.forEach(b => { b.vx *= -1; b.vy *= -1; }); }],
        ['Stop All', () => { blocks.forEach(b => { b.vx = 0; b.vy = 0; b.angularVelocity = 0; }); }],
        ['Randomize Colors', () => { blocks.forEach(b => { b.color = randomColor(); }); }],
        ['Randomize Shapes', () => { blocks.forEach(b => { b.shape = randomShape(); }); }],
        ['Spawn Wall', () => { blocks.push(makeBlock(canvas.width/2 - 200, canvas.height/2, '#333333', 'rectangle')); let b = blocks[blocks.length-1]; b.w = 400; b.h = 20; b.displayW = 400; b.displayH = 20; b.vx = 0; b.vy = 0; }],
        ['Spawn Random Cluster', () => { const cx = Math.random() * canvas.width; const cy = Math.random() * canvas.height; for(let i=0; i<5; i++) blocks.push(makeBlock(cx + (Math.random()-0.5)*100, cy + (Math.random()-0.5)*100)); }],
        ['Toggle Random Sizes', () => { randomSizeMode = !randomSizeMode; }],
        ['Toggle Jitter', () => { jitterMode = !jitterMode; }],
        ['Scale Up 10%', () => { blocks.forEach(b => { b.w *= 1.1; b.h *= 1.1; b.displayW *= 1.1; b.displayH *= 1.1; }); }],
        ['Scale Down 10%', () => { blocks.forEach(b => { b.w *= 0.9; b.h *= 0.9; b.displayW *= 0.9; b.displayH *= 0.9; }); }]
    ];
    geometryButtons.forEach(([name, action]) => { const btn = createButton(name, action); contentPages.geometry.appendChild(btn); });

    // === World Page ===
    const worldButtons = [
        ['Infinite Bounce (Walls)', () => { infiniteBounceMode = !infiniteBounceMode; physicsSettings.wallBounce = infiniteBounceMode ? 1.0 : 0.75; applyPhysicsSettings(); }],
        ['Toggle Gravity', () => { verticalMovement = !verticalMovement; }],
        ['Toggle Horizontal Movement', () => { horizontalMovement = !horizontalMovement; }],
        ['Gravity Flip', () => { gravityDir *= -1; }],
        ['Gravity Spin', () => { gravitySpin = !gravitySpin; }],
        ['Zero Gravity', () => { physicsSettings.gravity = 0; applyPhysicsSettings(); }],
        ['Heavy Gravity', () => { physicsSettings.gravity = 1.5; applyPhysicsSettings(); }],
        ['No Walls (Free Fall)', () => { mirrorMode = !mirrorMode; }],
        ['Walls are Sticky', () => { physicsSettings.wallBounce = 0.1; physicsSettings.friction = 0.5; applyPhysicsSettings(); }],
        ['Walls are Bouncy', () => { physicsSettings.wallBounce = 1.0; physicsSettings.restitution = 1.0; applyPhysicsSettings(); }],
        ['Reset World', () => { physicsSettings.gravity = 0.6; physicsSettings.wallBounce = 0.75; gravityDir = 1; verticalMovement = true; horizontalMovement = true; mirrorMode = false; applyPhysicsSettings(); }],
        ['Low Friction', () => { physicsSettings.friction = 0.98; applyPhysicsSettings(); }],
        ['High Friction', () => { physicsSettings.friction = 0.2; applyPhysicsSettings(); }],
        ['Time Warp (Slow)', () => { slowMo = 0.2; }],
        ['Time Warp (Fast)', () => { slowMo = 2.0; }],
        ['Time Normal', () => { slowMo = 1.0; }]
    ];
    worldButtons.forEach(([name, action]) => { const btn = createButton(name, action); contentPages.world.appendChild(btn); });

    // === Visuals Page ===
    const visualButtons = [
        ['Toggle Shadows', () => { shadowMode = !shadowMode; }], ['Toggle Glow', () => { glowMode = !glowMode; }], ['Neon Mode', () => { neonMode = !neonMode; }],
        ['Wireframe (Outline)', () => { wireframeMode = !wireframeMode; }], ['Glass Mode (Transparent)', () => { glassMode = !glassMode; }],
        ['High Contrast', () => { neonMode = false; glowMode = false; shadowMode = false; glassMode = false; wireframeMode = false; outlineOnly = true; }],
        ['Rainbow Outline', () => { outlineOnly = true; neonMode = true; }],
        ['Clear Visuals', () => { shadowMode = false; glowMode = false; neonMode = false; wireframeMode = false; glassMode = false; outlineOnly = false; }],
        ['Thick Trails', () => { trailMode = true; physicsSettings.trailLength = 50; }], ['Thin Trails', () => { trailMode = true; physicsSettings.trailLength = 5; }],
        ['Flash Mode', () => { flashMode = !flashMode; }], ['Cycle Backgrounds', () => { const bgColors = ['#0B0B1E', '#1a1a1a', '#200f14', '#0f2014']; let idx = 0; setInterval(() => { gui.style.setProperty('--background', bgColors[idx % bgColors.length]); idx++; }, 1000); }],
        ['Screenshot (Console)', () => { console.log("Canvas data URL logged."); console.log(canvas.toDataURL()); ctx.fillStyle = 'white'; ctx.fillRect(0,0,100,100); }],
        ['Hide Menu', () => { gui.style.display = 'none'; }], ['Outline Only', () => { outlineOnly = true; }]
    ];
    visualButtons.forEach(([name, action]) => { const btn = createButton(name, action); contentPages.visuals.appendChild(btn); });

    // === Settings Page ===
    const MOBILE_KEY = "XGUI_MOBILE_MODE_ENABLED";
    function enableMobile() { localStorage.setItem(MOBILE_KEY, "true"); document.body.classList.add("xgui-mobile-mode"); gui.style.width = "430px"; guiContent.style.left = "75px"; }
    function disableMobile() { localStorage.removeItem(MOBILE_KEY); document.body.classList.remove("xgui-mobile-mode"); gui.style.width = "800px"; guiContent.style.left = "70px"; }
    if (localStorage.getItem(MOBILE_KEY) === "true") setTimeout(() => enableMobile(), 50);
    const mobileToggleBtn = createButton('Toggle Mobile Mode', () => { if (document.body.classList.contains("xgui-mobile-mode")) { disableMobile(); } else { enableMobile(); } }); contentPages.settings.appendChild(mobileToggleBtn);

    // Keybinds
    const defaultHideKey = { ctrl: true, shift: false, alt: false, key: "e" };
    const defaultCloseKey = { ctrl: true, shift: false, alt: false, key: "x" };
    function parseKeybind({ shift, ctrl, alt, key }) { return [ctrl && "Ctrl", shift && "Shift", alt && "Alt", key && key.toUpperCase()].filter(Boolean).join(" + "); }
    function createKeybindListener(onpress, element = window) {
        return new Promise((resolve) => {
            const pressed = new Set(); let shift, ctrl, alt, key;
            const keydown = (e) => { e.preventDefault(); pressed.add(e.code); shift ||= e.shiftKey; ctrl ||= e.ctrlKey; alt ||= e.altKey; if (!["shift", "control", "alt", "meta"].includes(e.key.toLowerCase())) key = e.key.toLowerCase(); onpress?.({ shift, ctrl, alt, key }); };
            const keyup = (e) => { pressed.delete(e.code); if (pressed.size > 0) return; element.removeEventListener("keydown", keydown); element.removeEventListener("keyup", keyup); resolve({ shift, ctrl, alt, key }); };
            element.addEventListener("keydown", keydown); element.addEventListener("keyup", keyup);
        });
    }
    const settingsStore = { data: JSON.parse(localStorage.getItem("PhysicsGUISettings") || "{}"), save() { localStorage.setItem("PhysicsGUISettings", JSON.stringify(this.data)); } };
    settingsStore.data.hideKey ??= defaultHideKey; settingsStore.data.closeKey ??= defaultCloseKey;
    function createKeybindSetting(name, description, keyName) {
        const container = document.createElement('div'); container.style.cssText = "display: flex; justify-content: space-between; align-items: center; background: var(--background); padding: 10px; border-radius: 5px; margin-bottom: 5px;";
        const info = document.createElement('div'); info.innerHTML = `<strong>${name}</strong><br><small>${description}</small>`;
        const input = document.createElement('input'); input.readOnly = true; input.style.cssText = "width: 120px; padding: 5px; background: var(--background2); border: 1px solid var(--highlight); color: var(--textColor); text-align: center; cursor: pointer;"; input.value = parseKeybind(settingsStore.data[keyName]);
        input.onclick = async () => { input.value = "Press keys..."; const keys = await createKeybindListener((k) => input.value = parseKeybind(k)); settingsStore.data[keyName] = keys; settingsStore.save(); input.value = parseKeybind(keys); };
        container.append(info, input); return container;
    }
    contentPages.settings.appendChild(createKeybindSetting("Hide Keybind", "Toggle GUI visibility", "hideKey"));
    contentPages.settings.appendChild(createKeybindSetting("Close Keybind", "Close GUI & stop toggles", "closeKey"));
    
    // Themes
    const themes = {
        "X-GUI ORIGINAL": { highlight: "#8A2BE2", highlight2: "#4B0082", background: "#0B0B1E", background2: "#151534", textColor: "#E0E0FF", textColor2: "#9A8CFF", toggleOff: "#2C273F", toggleOn: "#5FA3FF" },
        "Crypto Hack": { highlight: "rgb(88 175 88)", toggleOn: "#0b601b", background: "radial-gradient(#11581e,#041607)", background2: "#1a1a1a", toggleOff: "#A02626", highlight2: "#49d149", textColor2: "#49d149" },
        "Factory": { highlight: "#1563bf", toggleOn: "rgb(75, 194, 46)", background: "#3a3a3a", background2: "#2d313d", toggleOff: "#9a49aa", highlight2: "rgb(0 0 0 / 25%)", textColor2: "#a5aabe" },
        "Cafe": { highlight: "#0bc2cf", toggleOn: "#47A547", background: "linear-gradient(90deg,rgba(200,0,0,.5) 50%,transparent 0) center / 50px 50px,linear-gradient(rgba(200,0,0,0.5) 50%,transparent 0) white center / 50px 50px", background2: "rgb(64, 64, 64)", toggleOff: "#A02626", highlight2: "rgb(0 0 0 / 25%)", textColor2: "#ac7339", textColor: "#FFFFFF" }
    };
    const themeLabel = document.createElement('div'); themeLabel.innerText = "Themes:"; themeLabel.style.cssText = "color: var(--textColor); font-weight: 800; margin-top: 15px; margin-bottom: 5px;"; contentPages.settings.appendChild(themeLabel);
    Object.keys(themes).forEach(themeName => {
        const btn = createButton(themeName, () => {
            const t = themes[themeName]; for (const prop in t) { gui.style.setProperty("--" + prop, t[prop]); settingsStore.data.theme = settingsStore.data.theme || {}; settingsStore.data.theme[prop] = t[prop]; } settingsStore.save();
        }); contentPages.settings.appendChild(btn);
    });

    // === VOICE / MICROPHONE PAGE ===
    const voiceButtons = [
        ['Audio Pulse (Size)', () => { audioPulseMode = !audioPulseMode; if (audioPulseMode) startAudio(); }],
        ['Voice Pitch Size', () => { pitchSizeMode = !pitchSizeMode; if (pitchSizeMode) startAudio(); }],
        ['Voice Shake', () => { voiceShakeMode = !voiceShakeMode; if (voiceShakeMode) startAudio(); }],
        ['Voice Spawn (Auto)', () => { voiceSpawnMode = !voiceSpawnMode; if (voiceSpawnMode) startAudio(); }],
        ['Stop All Voice', () => { audioPulseMode = false; pitchSizeMode = false; voiceShakeMode = false; voiceSpawnMode = false; }]
    ];
    const voiceInfo = document.createElement('div');
    voiceInfo.innerHTML = "Requires Microphone Access. Speak, play music, or make noise! <br><br><b>Pitch Size:</b> High pitch = Big shapes. <br><b>Voice Shake:</b> Loud noise = Screen shake. <br><b>Voice Spawn:</b> Loud noise creates shapes.";
    voiceInfo.style = "background: #151515; color: #ccc; padding: 8px; border: 1px solid #333; border-radius: 5px; margin-bottom: 5px; font-size: 12px;";
    contentPages.voice.appendChild(voiceInfo);
    voiceButtons.forEach(([name, action]) => { const btn = createButton(name, action); contentPages.voice.appendChild(btn); });

    // === CHAOS PAGE (20 Random Buttons) ===
    const chaosInfo = document.createElement('div');
    chaosInfo.innerHTML = "<b>WARNING: UNSTABLE EXPERIMENTS</b><br>Click at your own risk. These are random chaos functions.";
    chaosInfo.style = "background: #400000; color: #ffaaaa; padding: 5px; border: 1px solid #f00; margin-bottom: 5px; font-size: 12px; font-weight: bold; text-align: center;";
    contentPages.chaos.appendChild(chaosInfo);

    const chaosButtons = [
        // 1-5: Physics Breakers
        ['1. Hyper Speed', () => { hyperSpeed = !hyperSpeed; slowMo = hyperSpeed ? 2.5 : 1.0; }],
        ['2. Jitter Physics', () => { jitterPhysics = !jitterPhysics; }],
        ['3. Elastic Walls', () => { elasticWalls = !elasticWalls; if(elasticWalls) { wallBounce = 1.5; restitution = 1.2; } else { wallBounce = 0.75; restitution = 1.0; } applyPhysicsSettings(); }],
        ['4. Anti-Gravity', () => { antiGravityMode = !antiGravityMode; }],
        ['5. Gravity Tunnel', () => { gravityTunnel = !gravityTunnel; }],
        
        // 6-10: Visual Glitches
        ['6. Pixelate Mode', () => { pixelate = !pixelate; if(pixelate) { ctx.imageSmoothingEnabled = false; canvas.style.imageRendering = 'pixelated'; } else { ctx.imageSmoothingEnabled = true; canvas.style.imageRendering = 'auto'; } }],
        ['7. Invert Colors', () => { invertColors = !invertColors; canvas.style.filter = invertColors ? 'invert(1)' : 'none'; }],
        ['8. Glitch Mode', () => { glitchMode = !glitchMode; }],
        ['9. Neon Rain', () => { neonRain = !neonRain; }],
        ['10. Disco Mode', () => { discoMode = !discoMode; }],

        // 11-15: Spawning & Objects
        ['11. Big Bertha', () => { bigBertha = !bigBertha; }],
        ['12. Tiny Tims', () => { tinyTims = !tinyTims; }],
        ['13. Chaos Spawner', () => { chaosSpawner = !chaosSpawner; }],
        ['14. Electron Orbit', () => { electronMode = !electronMode; }],
        ['15. Perimeter Only', () => { perimeterOnly = !perimeterOnly; }],

        // 16-20: Screen & System
        ['16. Shake Camera', () => { shakeCam = !shakeCam; }],
        ['17. Dark Mode', () => { darkMode = !darkMode; if(darkMode) gui.style.setProperty('--background', '#000000'); else gui.style.setProperty('--background', '#0B0B1E'); }],
        ['18. Rainbow Edges', () => { rainbowEdges = !rainbowEdges; }],
        ['19. Spiral Force', () => { spiralForce = !spiralForce; }],
        ['20. MAGNETIZE', () => { magnetize = !magnetize; }]
    ];

    chaosButtons.forEach(([name, action]) => {
        const btn = createButton(name, action, true);
        contentPages.chaos.appendChild(btn);
    });

    // === Sidebar Navigation ===
    function createSidebarPath(name, icon, page) {
        const sidebarPath = document.createElement("div"); Object.assign(sidebarPath.style, { display: 'flex', alignItems: 'center', cursor: 'pointer', padding: '10px', transition: 'all 0.2s', color: 'var(--textColor)' }); sidebarPath.className = 'X-Gui-sidebarPath';
        const iconElement = document.createElement("div"); iconElement.innerHTML = icon; Object.assign(iconElement.style, { width: '30px', height: '30px', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '10px', fontSize: '18px' });
        const nameElement = document.createElement("span"); nameElement.innerText = name; Object.assign(nameElement.style, { fontSize: '14px', fontWeight: '700' });
        sidebarPath.appendChild(iconElement); sidebarPath.appendChild(nameElement);
        sidebarPath.onclick = () => { Object.values(contentPages).forEach(p => p.style.display = 'none'); page.style.display = 'flex'; pathText.innerText = name; };
        return sidebarPath;
    }
    // Add new sidebar items
    sidebarPaths.appendChild(createSidebarPath("Search & Macros", '<i class="fas fa-search"></i>', contentPages.search));
    sidebarPaths.appendChild(createSidebarPath("Spawn Options", '<i class="fas fa-plus-circle"></i>', contentPages.geometry)); // Routing geometry to Spawn view for context
    sidebarPaths.appendChild(createSidebarPath("Core Controls", '<i class="fas fa-sliders-h"></i>', contentPages.core));
    sidebarPaths.appendChild(createSidebarPath("Voice / Mic", '<i class="fas fa-microphone"></i>', contentPages.voice));
    sidebarPaths.appendChild(createSidebarPath("Chaos (20)", '<i class="fas fa-bolt"></i>', contentPages.chaos));
    sidebarPaths.appendChild(createSidebarPath("Color Controls", '<i class="fas fa-palette"></i>', contentPages.color));
    sidebarPaths.appendChild(createSidebarPath("Visuals", '<i class="fas fa-eye"></i>', contentPages.visuals));
    sidebarPaths.appendChild(createSidebarPath("Particle Effects", '<i class="fas fa-sparkles"></i>', contentPages.particle));
    sidebarPaths.appendChild(createSidebarPath("World / Env", '<i class="fas fa-globe"></i>', contentPages.world));
    sidebarPaths.appendChild(createSidebarPath("Fun Controls", '<i class="fas fa-gamepad"></i>', contentPages.fun));
    sidebarPaths.appendChild(createSidebarPath("Physics Settings", '<i class="fas fa-cog"></i>', contentPages.physics));
    sidebarPaths.appendChild(createSidebarPath("Illusions", '<i class="fas fa-hat-wizard"></i>', contentPages.illusions));
    sidebarPaths.appendChild(createSidebarPath("Settings", '<i class="fas fa-sliders-h"></i>', contentPages.settings));
    
    // Add header to Geometry page to distinguish it as Spawn
    const geomHeader = document.createElement('h3');
    geomHeader.innerText = "Shape Spawner";
    geomHeader.style = "margin-top:0; color:#8A2BE2; border-bottom:1px solid #333; padding-bottom:5px;";
    contentPages.geometry.prepend(geomHeader);

    contentPages.search.style.display = 'flex';
    
    // === Toggle menu with key ===
    window.addEventListener('keydown', (e) => {
        const hideK = settingsStore.data.hideKey;
        if (e.key.toLowerCase() === hideK.key && e.ctrlKey === !!hideK.ctrl && e.shiftKey === !!hideK.shift && e.altKey === !!hideK.alt) {
            gui.style.display = gui.style.display === 'none' ? 'block' : 'none';
        }
    });
    
    // === Input Logic ===
    let draggingBlock = null;
    function getPos(e) { return e.touches && e.touches.length ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY }; }
    
    function startDrag(e) {
        const { x, y } = getPos(e);
        prevMouseX = x; prevMouseY = y;
        for (const b of blocks) { if (x > b.x && x < b.x + b.w && y > b.y && y < b.y + b.h) { b.isDragging = true; draggingBlock = b; return; } }
        for (const d of dynamites) { if (x > d.x && x < d.x + d.w && y > d.y && y < d.y + d.h) { d.isDragging = true; return; } }
    }
    function moveDrag(e) {
        const { x, y } = getPos(e);
        if (lockMouse) return; // Chaos: Lock Mouse
        if (draggingBlock) { draggingBlock.x += x - prevMouseX; draggingBlock.y += y - prevMouseY; draggingBlock.vx = (x - prevMouseX) * 0.8; draggingBlock.vy = (y - prevMouseY) * 0.8; draggingBlock.angularVelocity = (x - prevMouseX) * 0.01; }
        prevMouseX = x; prevMouseY = y;
    }
    function endDrag() { if (draggingBlock) draggingBlock.isDragging = false; draggingBlock = null; dynamites.forEach((d) => (d.isDragging = false)); }
    
    canvas.addEventListener('mousemove', (e) => { lastMouseX = e.clientX; lastMouseY = e.clientY; mouseX = e.clientX; mouseY = e.clientY; if (lockMouse && draggingBlock) { prevMouseX = mouseX; prevMouseY = mouseY; } });
    canvas.addEventListener('mousedown', startDrag); canvas.addEventListener('mousemove', moveDrag); canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('touchstart', startDrag); canvas.addEventListener('touchmove', moveDrag); canvas.addEventListener('touchend', endDrag);
    window.addEventListener('resize', () => { canvas.width = innerWidth; canvas.height = innerHeight; });
    
    // === Physics Logic ===
    function handleCollisions() {
        if (frameCount % performanceSettings.collisionCheckInterval !== 0) return 0;
        const newCollisions = new Set();
        let hasRolling = false;
        spatialGrid.clear(); blocks.forEach(block => spatialGrid.addObject(block));
        blocks.forEach((block, i) => {
            const nearby = spatialGrid.getNearbyObjects(block);
            nearby.forEach(other => {
                const j = blocks.indexOf(other); if (i >= j) return;
                if (block.x < other.x + other.w && block.x + block.w > other.x && block.y < other.y + other.h && block.y + block.h > other.y) {
                    const overlapX = Math.min(block.x + block.w - other.x, other.x + other.w - block.x);
                    const overlapY = Math.min(block.y + block.h - other.y, other.y + other.h - block.y);
                    const id = `${i}-${j}`; newCollisions.add(id);
                    const relV = Math.sqrt((block.vx - other.vx) ** 2 + (block.vy - other.vy) ** 2);
                    if (overlapY > overlapX && relV > 0.5 && relV < 3) hasRolling = true;
                    if (!activeCollisions.has(id) && soundCooldowns.collision <= 0) { playSound('collision'); soundCooldowns.collision = SOUND_COOLDOWN_TIME; }
                    if (overlapX < overlapY) {
                        const sx = overlapX * 0.5; if (block.x < other.x) { block.x -= sx; other.x += sx; } else { block.x += sx; other.x -= sx; }
                        const dvx = block.vx - other.vx; const totalMass = block.mass + other.mass; const impulse = ((1 + restitution) * dvx) / totalMass;
                        block.vx -= impulse * other.mass; other.vx += impulse * block.mass;
                        block.rotationSpeed += (Math.random() - 0.5) * 0.05; other.rotationSpeed += (Math.random() - 0.5) * 0.05;
                    } else {
                        const sy = overlapY * 0.5; if (block.y < other.y) { block.y -= sy; other.y += sy; } else { block.y += sy; other.y -= sy; }
                        const dvy = block.vy - other.vy; const totalMass = block.mass + other.mass; const impulse = ((1 + restitution) * dvy) / totalMass;
                        block.vy -= impulse * other.mass; other.vy += impulse * block.mass;
                        block.rotationSpeed += (Math.random() - 0.5) * 0.05; other.rotationSpeed += (Math.random() - 0.5) * 0.05;
                    }
                }
            });
        });
        if (hasRolling && soundCooldowns.rolling <= 0) { playSound('rolling'); soundCooldowns.rolling = 200; }
        activeCollisions.clear(); newCollisions.forEach((id) => activeCollisions.add(id));
        return 0;
    }
    
    // === Magnetize Logic (Fixed) ===
    function applyMagnetize() {
        // Only run if explicitly enabled or needed
        if (!magnetize && !centerPull && !spiralForce && !gravityTunnel) return;

        const mx = lastMouseX;
        const my = lastMouseY;
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        blocks.forEach((b) => {
            // 1. Standard Magnetize (Mouse)
            if (magnetize) {
                const dx = mx - (b.x + b.w/2);
                const dy = my - (b.y + b.h/2);
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                const dir = magnetInvert ? -1 : 1;
                const maxForce = magnetStrength * 50;
                const force = Math.min(maxForce, maxForce / (dist * 0.01));
                b.vx += (dx/dist) * force * dir * 0.1;
                b.vy += (dy/dist) * force * dir * 0.1;
            }

            // 2. Center Pull (Black Hole)
            if (centerPull) {
                const dx = cx - (b.x + b.w/2);
                const dy = cy - (b.y + b.h/2);
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                const maxForce = 80;
                const force = Math.min(maxForce, maxForce / (dist * 0.02));
                b.vx += (dx/dist) * force * 0.05;
                b.vy += (dy/dist) * force * 0.05;
            }

            // 3. Spiral Force (Chaos)
            if (spiralForce) {
                const dx = cx - (b.x + b.w/2);
                const dy = cy - (b.y + b.h/2);
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                const angle = Math.atan2(dy, dx);
                const tangentX = -Math.sin(angle);
                const tangentY = Math.cos(angle);
                const force = 30 / Math.max(1, dist*0.05);
                b.vx += tangentX * force;
                b.vy += tangentY * force;
            }

            // 4. Gravity Tunnel (Vertical Swirl)
            if (gravityTunnel) {
                b.vy += 0.2; // Stronger Gravity
                const dx = b.x + b.w/2 - cx;
                if (Math.abs(dx) > 10) {
                    b.vx -= dx * 0.001; // Pull to center X
                }
            }
        });
    }
    
    function applyVoicePhysics() {
        if (!audioInitialized) return;
        // ... (Existing Voice Logic: Pulse, Pitch, Shake, Spawn) ...
        if (audioPulseMode && audioIntensity > 0.1) {
            const scale = 1 + (audioIntensity * 0.5);
            blocks.forEach(b => { b.displayW = b.w * scale; b.displayH = b.h * scale; b.color = `hsl(${(Date.now()/5) % 360}, 100%, 60%)`; });
        } else if (audioPulseMode) { blocks.forEach(b => { b.displayW = b.w; b.displayH = b.h; }); }

        if (pitchSizeMode && audioPitch > 0.1) {
            blocks.forEach(b => { const pitchScale = 1 + (audioPitch * 1.5); b.displayW = b.w * pitchScale; b.displayH = b.h * pitchScale; });
        } else if (pitchSizeMode) { blocks.forEach(b => { b.displayW = b.w; b.displayH = b.h; }); }

        if (voiceShakeMode && audioIntensity > 0.2) {
            const mag = audioIntensity * 10;
            blocks.forEach(b => { b.x += (Math.random() - 0.5) * mag; b.y += (Math.random() - 0.5) * mag; });
            canvas.style.transform = `translate(${(Math.random()-0.5)*mag}px, ${(Math.random()-0.5)*mag}px)`;
        } else if (voiceShakeMode) { canvas.style.transform = 'none'; }

        if (voiceSpawnMode && audioIntensity > 0.6 && frameCount % 10 === 0) {
            blocks.push(makeBlock(Math.random() * canvas.width, Math.random() * canvas.height, randomColor(), randomShape()));
        }
    }
    
    function applyIllusions(t) {
        const cx = canvas.width / 2, cy = canvas.height / 2;
        // ... (Existing Illusions Logic) ...
        if (illusionsActive.spiral) {
            ensureBlocks(80); const turns = 3; const speed = 0.8;
            blocks.forEach((b, i) => {
                const a = (i / blocks.length) * turns * Math.PI * 2 + t * speed;
                const r = (i / blocks.length) * Math.min(cx, cy) * 0.95;
                const x = cx + Math.cos(a) * r, y = cy + Math.sin(a) * r;
                b.x = x - 15; b.y = y - 15; b.displayW = b.displayH = 30; b.w = b.h = 30;
                b.color = (i + Math.floor(t * 4 + r / 40)) % 2 === 0 ? '#000' : '#fff'; b.shape = 'rectangle'; b.rotation = a + Math.PI / 2;
            });
        }
        if (illusionsActive.breathingGrid) {
            ensureBlocks(80); const cols = 10; const rows = 8; const amp = 0.4; const scale = 1 + Math.sin(t * 2) * amp;
            const cellW = (canvas.width * 0.8) / cols; const cellH = (canvas.height * 0.8) / rows; let idx = 0;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++, idx++) {
                    const b = blocks[idx]; const baseX = canvas.width * 0.1 + c * cellW; const baseY = canvas.height * 0.1 + r * cellH;
                    b.displayW = b.displayH = Math.min(cellW, cellH) * 0.6 * scale; b.w = b.h = b.displayW;
                    b.x = baseX + cellW / 2 - b.displayW / 2; b.y = baseY + cellH / 2 - b.displayH / 2;
                    b.color = (c + r) % 2 === 0 ? '#fff' : '#000'; b.shape = 'rectangle'; b.rotation = 0;
                }
            }
        }
        if (illusionsActive.waveTunnel) {
            ensureBlocks(80); const layers = 6;
            blocks.forEach((b, i) => {
                const ring = i % layers; const ang = (i / blocks.length) * Math.PI * 2 * layers;
                const baseR = ((ring + 1) / (layers + 1)) * Math.min(cx, cy) * 0.95; const r = baseR + Math.sin(t * 3 + ring) * 15;
                const x = cx + Math.cos(ang) * r, y = cy + Math.sin(ang) * r;
                b.x = x - 10; b.y = y - 10; b.displayW = b.displayH = 20 + ring * 2; b.w = b.h = b.displayW;
                b.color = (ring + Math.floor(t * 6)) % 2 === 0 ? '#fff' : '#000'; b.shape = 'circle'; b.rotation = 0;
            });
        }
        if (illusionsActive.vortex) {
            ensureBlocks(80);
            blocks.forEach((b, i) => {
                const a = (i / blocks.length) * Math.PI * 4 + t * 2; const r = (i / blocks.length) * Math.min(cx, cy);
                const x = cx + Math.cos(a) * r, y = cy + Math.sin(a) * r;
                b.x = x - 8; b.y = y - 8; b.displayW = b.displayH = 16; b.w = b.h = 16;
                b.color = i % 2 === 0 ? '#fff' : '#000'; b.shape = 'triangle'; b.rotation = a + Math.PI / 2;
            });
        }
        if (illusionsActive.orbitRing) {
            ensureBlocks(80); const rings = 4; const per = Math.floor(blocks.length / rings);
            for (let r = 0; r < rings; r++) {
                const radius = ((r + 1) / (rings + 1)) * Math.min(cx, cy) * 0.9;
                for (let j = 0; j < per; j++) {
                    const idx = r * per + j; const b = blocks[idx];
                    const a = (j / per) * Math.PI * 2 + t * (r % 2 === 0 ? 0.8 : -0.8);
                    const x = cx + Math.cos(a) * radius, y = cy + Math.sin(a) * radius;
                    b.x = x - 6; b.y = y - 6; b.displayW = b.displayH = 12; b.w = b.h = 12;
                    b.color = j % 2 === 0 ? '#fff' : '#000'; b.shape = 'circle'; b.rotation = 0;
                }
            }
        }
        if (illusionsActive.checkerSpin) {
            ensureBlocks(64); const n = 8; const size = Math.min(canvas.width, canvas.height) * 0.6; const cell = size / n; const angle = t * 1.2;
            for (let i = 0; i < n * n; i++) {
                const b = blocks[i]; const row = Math.floor(i / n); const col = i % n;
                const lx = (col + 0.5) * cell - size / 2; const ly = (row + 0.5) * cell - size / 2;
                const rx = lx * Math.cos(angle) - ly * Math.sin(angle); const ry = lx * Math.sin(angle) + ly * Math.cos(angle);
                b.displayW = b.displayH = cell * 0.9; b.w = b.h = b.displayW; b.x = cx + rx - b.displayW / 2; b.y = cy + ry - b.displayH / 2;
                b.color = (row + col) % 2 === 0 ? '#fff' : '#000'; b.shape = 'rectangle'; b.rotation = 0;
            }
        }
        if (illusionsActive.flipStrip) {
            ensureBlocks(40); const yCenter = cy;
            blocks.forEach((b, i) => {
                const phase = (i / blocks.length) * Math.PI * 4; const offset = Math.sin(t * 4 + phase) * 40;
                b.displayW = 30; b.displayH = 30; b.w = b.h = 30; b.x = (i / blocks.length) * canvas.width;
                b.y = yCenter - b.displayH / 2 + offset * (i % 2 === 0 ? 1 : -1);
                b.color = i % 2 === 0 ? '#fff' : '#000'; b.shape = 'rectangle'; b.rotation = 0;
            });
        }
        if (illusionsActive.zoomPulse) {
            ensureBlocks(60); const layers = 5; const per = Math.floor(blocks.length / layers);
            for (let r = 0; r < layers; r++) {
                const base = ((r + 1) / (layers + 1)) * Math.min(cx, cy); const pulse = 1 + Math.sin(t * 3 + r) * 0.2; const radius = base * pulse;
                for (let j = 0; j < per; j++) {
                    const idx = r * per + j; const b = blocks[idx]; const a = (j / per) * Math.PI * 2;
                    b.x = cx + Math.cos(a) * radius - 6; b.y = cy + Math.sin(a) * radius - 6;
                    b.displayW = b.displayH = 12; b.w = b.h = 12; b.color = j % 2 === 0 ? '#fff' : '#000'; b.shape = 'circle'; b.rotation = 0;
                }
            }
        }
        if (illusionsActive.swirlField) {
            ensureBlocks(80); const R = 200;
            blocks.forEach((b, i) => {
                const dx = b.x + b.w/2 - mouseX, dy = b.y + b.h/2 - mouseY; const dist = Math.sqrt(dx*dx + dy*dy) || 1; const factor = Math.max(0, 1 - dist / R);
                const angle = t * 5 * factor; const sx = Math.cos(angle) * dx - Math.sin(angle) * dy; const sy = Math.sin(angle) * dx + Math.cos(angle) * dy;
                const x = mouseX + sx, y = mouseY + sy;
                b.displayW = b.displayH = 10 + factor * 15; b.w = b.h = b.displayW; b.x = x - b.displayW / 2; b.y = y - b.displayH / 2;
                b.color = factor > 0.5 ? '#fff' : '#000'; b.shape = i % 2 === 0 ? 'circle' : 'rectangle'; b.rotation = 0;
            });
        }
        if (illusionsActive.hypnoHue) {
            const hueBase = (t * 80) % 360; blocks.forEach((b, i) => { const f = i / Math.max(1, blocks.length); const hue = (hueBase + f * 180) % 360; b.color = `hsl(${hue},100%,60%)`; });
        }
    }

    // Helper for illusions to ensure block count
    function ensureBlocks(count) {
        if (blocks.length < count) {
            for (let i = blocks.length; i < count; i++) {
                blocks.push(makeBlock(Math.random() * canvas.width, Math.random() * canvas.height));
            }
        }
    }
    
    function explode(d) {
        d.exploded = true; playSound('explosion'); const blastRadius = 250; const blastPower = 50;
        blocks.forEach((b) => {
            const dx = b.x + b.w/2 - (d.x + d.w/2), dy = b.y + b.h/2 - (d.y + d.h/2); const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < blastRadius && dist > 0) { const force = (1 - dist / blastRadius) * blastPower; b.vx += (dx/dist) * force; b.vy += (dy/dist) * force - 8; b.angularVelocity = (Math.random() - 0.5) * 0.4; }
        });
        for (let i = 0; i < 30; i++) particles.push(makeParticle(d.x + d.w/2, d.y + d.h/2, d.color));
        const start = performance.now();
        const tick = () => { if (performance.now() - start < 500) requestAnimationFrame(tick); else { const idx = dynamites.indexOf(d); if (idx !== -1) dynamites.splice(idx, 1); } };
        tick();
    }
    
    // === OPTIMIZATION: Improved Update Loop ===
    function update() {
        frameCount++;
        updateAudioData(); // Analyze Audio
        
        // Chaos: Jitter Physics (Random Force)
        if (jitterPhysics && frameCount % 2 === 0) {
            blocks.forEach(b => {
                b.vx += (Math.random() - 0.5) * 1.5;
                b.vy += (Math.random() - 0.5) * 1.5;
            });
        }

        // Chaos: Chaos Spawner
        if (chaosSpawner && frameCount % 60 === 0) {
            blocks.push(makeBlock(Math.random() * canvas.width, Math.random() * canvas.height, randomColor(), randomShape()));
        }

        if (frameCount % 2 === 0 && colorPulseMode) { pulsePhase += pulseSpeed; if (pulsePhase > 1) pulsePhase = 0; }
        for (const k in soundCooldowns) { if (soundCooldowns[k] > 0) soundCooldowns[k] -= 16.67; }
        if (frameCount % performanceSettings.particleUpdateInterval === 0) updateEffectParticles();
        
        const t = performance.now() / 1000;
        if (gravityWave) gravity = 0.6 + Math.sin(t * 2) * 0.4;
        if (gravitySpin) gravityDir = Math.sin(t) >= 0 ? 1 : -1;
        
        applyVoicePhysics();

        const screenBounds = { left: -100, right: canvas.width + 100, top: -100, bottom: canvas.height + 100 };
        
        blocks.forEach((b) => {
            // Chaos: Electron Mode (Constant velocity towards mouse)
            if (electronMode && mouseX > 0) {
                const dx = mouseX - (b.x + b.w/2);
                const dy = mouseY - (b.y + b.h/2);
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                b.vx += (dx/dist) * 0.5;
                b.vy += (dy/dist) * 0.5;
            }

            if (jitterMode && frameCount % 2 === 0) { b.x += (Math.random() - 0.5) * 2; b.y += (Math.random() - 0.5) * 2; }
            if (!mirrorMode && (b.x + b.w < screenBounds.left || b.x > screenBounds.right || b.y + b.h < screenBounds.top || b.y > screenBounds.bottom)) return;
            
            if (b.vx !== 0 || b.vy !== 0) { b.trail.push({ x: b.x + b.w/2, y: b.y + b.h/2, age: 0 }); if (b.trail.length > b.maxTrailLength) b.trail.shift(); }
            if (frameCount % 4 === 0) b.trail.forEach((p) => p.age++);
            
            if (shrinkMode || growMode) { b.displayW += (targetSize.width - b.displayW) * 0.1; b.displayH += (targetSize.height - b.displayH) * 0.1; b.w = b.displayW; b.h = b.displayH; }
            
            if (!b.isDragging) {
                if (antiGravityMode) b.vy -= gravity * 0.5 * slowMo; else if (verticalMovement) b.vy += gravity * gravityDir * slowMo;
                b.vx *= airResistance; b.vy *= airResistance; if (!horizontalMovement) b.vx = 0;
                
                // Chaos: HyperSpeed (Force multiplier)
                if (hyperSpeed) { b.vx *= 1.1; b.vy *= 1.1; }

                if (tornadoMode) {
                    const cx = canvas.width / 2, cy = canvas.height / 2;
                    const dx = b.x + b.w/2 - cx, dy = b.y + b.h/2 - cy, dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    const angle = Math.atan2(dy, dx), tangentX = -Math.sin(angle), tangentY = Math.cos(angle);
                    const spiralStrength = 150 / Math.max(1, dist*0.01), pullStrength = 50 / Math.max(1, dist*0.01);
                    b.vx += tangentX * spiralStrength * 0.1 - (dx/dist) * pullStrength * 0.05;
                    b.vy += tangentY * spiralStrength * 0.1 - (dy/dist) * pullStrength * 0.05;
                    b.rotationSpeed += 0.1;
                }
                
                b.x += b.vx * slowMo; b.y += b.vy * slowMo;
                
                if (mirrorMode) { if (b.x > canvas.width) b.x = -b.w; if (b.x + b.w < 0) b.x = canvas.width; if (b.y > canvas.height) b.y = -b.h; if (b.y + b.h < 0) b.y = canvas.height; }
                
                if (rotateMode) { b.rotation += (b.rotationSpeed || 0.05); b.rotationSpeed *= 0.99; }
                
                if (sizeWaveMode) {
                    const wave = Math.sin(performance.now() / 500 + b.x / 100);
                    b.w = blockSize + wave * 30; b.h = blockSize + wave * 30; b.displayW = b.w; b.displayH = b.h;
                }
                
                let bounced = false; 
                // Chaos: Elastic Walls
                let currentWallBounce = elasticWalls ? 1.5 : wallBounce;
                let currentRestitution = elasticWalls ? 1.2 : restitution;
                
                const energyLoss = 1 - (physicsSettings.collisionEnergyLoss || 0);
                
                // Perimeter Only (Chaos)
                if (perimeterOnly) {
                    if (b.x < 50 || b.x > canvas.width - 50 || b.y < 50 || b.y > canvas.height - 50) {
                         // Apply strong force to center
                         const cx = canvas.width/2; const cy = canvas.height/2;
                         const dx = cx - (b.x + b.w/2); const dy = cy - (b.y + b.h/2);
                         const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                         b.vx += (dx/dist) * 2; b.vy += (dy/dist) * 2;
                    }
                }

                if (b.y + b.h > canvas.height) { b.y = canvas.height - b.h; b.vy *= -currentWallBounce * energyLoss; b.vx *= friction; bounced = true; }
                else if (b.y < 0) { b.y = 0; b.vy *= -currentWallBounce * energyLoss; b.vx *= friction; bounced = true; }
                if (b.x + b.w > canvas.width) { b.x = canvas.width - b.w; b.vx *= -currentWallBounce * energyLoss; b.vy *= friction; bounced = true; }
                else if (b.x < 0) { b.x = 0; b.vx *= -currentWallBounce * energyLoss; b.vy *= friction; bounced = true; }
                
                if (bounced && soundCooldowns.bounce <= 0) {
                    const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy); if (speed > 2) { playSound('bounce'); soundCooldowns.bounce = SOUND_COOLDOWN_TIME; }
                }
            }
            
            if (frameCount % 3 === 0) {
                // Chaos: Disco Mode (Random Colors)
                if (discoMode) { b.color = `hsl(${Math.random() * 360}, 100%, 50%)`; }
                
                if (colorPulseMode) { const f = (Math.sin(pulsePhase * Math.PI * 2) + 1) / 2; b.color = interpolateColor(pulseColor1, pulseColor2, f); }
                else if (rainbowMode) { b.color = `hsl(${(performance.now() / 10 + b.x) % 360},100%,60%)`; }
                else if (neonMode) {
                     b.color = b.color.replace(/hsl\((\d+),(\d+)%,(\d+)%\)/, (m, h, s, l) => `hsl(${h}, 100%, 60%)`);
                     b.color = b.color.replace(/rgb\((\d+),(\d+),(\d+)\)/, (m, r, g, b) => `rgb(0, ${Math.max(g, 150)}, 255)`);
                }
            }
        });
        
        applyIllusions(t);
        
        dynamites.forEach((d) => {
            if (d.exploded) return;
            if (!d.isDragging) { d.vy += gravity; d.vx *= airResistance; d.vy *= airResistance; d.x += d.vx; d.y += d.vy; if (d.y + d.h > canvas.height) { d.y = canvas.height - d.h; d.vy *= -0.3; d.vx *= 0.8; } }
            d.timer--; if (d.timer <= 0 && !d.exploded) explode(d);
        });
        
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i]; p.vy += p.gravity || 0.2; p.vx *= p.airResistance || 0.99; p.vy *= p.airResistance || 0.99; p.x += p.vx; p.y += p.vy; p.life--;
            if (p.life <= 0) { if (particlePool.length < 100) particlePool.push(p); particles.splice(i, 1); }
        }
        
        if (magnetize || centerPull || spiralForce || gravityTunnel) applyMagnetize();
        if (collisionsEnabled) handleCollisions();
    }
    
    function draw() {
        if (frameCount % performanceSettings.renderInterval !== 0) return;

        // Chaos: Shake Camera (Visual only)
        if (shakeCam) {
            const mag = 10;
            ctx.setTransform(1, 0, 0, 1, (Math.random()-0.5)*mag, (Math.random()-0.5)*mag);
        } else {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        if (!trailMode) ctx.clearRect(0, 0, canvas.width, canvas.height);
        else { ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
        
        const visibleParticles = particles.filter(p => p.x > -50 && p.x < canvas.width + 50 && p.y > -50 && p.y < canvas.height + 50);
        
        if (trailMode) {
            ctx.lineWidth = 2;
            blocks.forEach((b) => {
                if (b.trail.length > 1) {
                    ctx.strokeStyle = b.color; ctx.beginPath();
                    const trailStep = Math.max(1, Math.floor(b.trail.length / 10));
                    for (let i = 0; i < b.trail.length; i += trailStep) {
                        const pt = b.trail[i]; const alpha = (1 - pt.age / b.maxTrailLength) * 0.5; ctx.globalAlpha = alpha;
                        if (i === 0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.stroke(); ctx.globalAlpha = 1;
                }
            });
        }
        
        effectParticles.forEach((p) => {
            // Chaos: Neon Rain (Visual override)
            if (neonRain) { p.color = '#0f0'; p.size = 2; p.life = 200; }
            
            ctx.fillStyle = p.color; ctx.globalAlpha = p.life / (p.maxLife || 100);
            if (p.type === 'sparkle' && p.twinkle) ctx.globalAlpha *= Math.abs(Math.sin(p.twinkle));
            if (p.type === 'electric' && p.intensity) ctx.globalAlpha *= 0.3 + p.intensity * 0.7;
            if (p.type === 'plasma' && p.energy) ctx.globalAlpha *= 0.5 + Math.sin(performance.now() / 100 + p.energy * 10) * 0.5;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
        });
        ctx.globalAlpha = 1;
        
        visibleParticles.forEach((p) => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 100; ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size); });
        ctx.globalAlpha = 1;
        
        const visibleBlocks = blocks.filter(b => b.x + b.w > -50 && b.x < canvas.width + 50 && b.y + b.h > -50 && b.y < canvas.height + 50);
        
        // Chaos: Glitch Mode (Visual jitter)
        let glitchOffsetX = 0;
        let glitchOffsetY = 0;
        if (glitchMode) {
            if (frameCount % 10 === 0) {
                glitchOffsetX = (Math.random() - 0.5) * 20;
                glitchOffsetY = (Math.random() - 0.5) * 10;
            }
            // Random color channel splitting simulation
            ctx.globalCompositeOperation = (frameCount % 2 === 0) ? 'screen' : 'source-over';
        }

        if (shadowMode) { ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(0,0,0,0.5)'; }
        else if (glowMode) { ctx.shadowBlur = 15; ctx.shadowColor = '#ffffff'; }
        else ctx.shadowBlur = 0;
        if (glassMode) ctx.globalAlpha = 0.3;
        
        const rectangles = visibleBlocks.filter(b => b.shape === 'rectangle');
        const circles = visibleBlocks.filter(b => b.shape === 'circle');
        const triangles = visibleBlocks.filter(b => b.shape === 'triangle');
        
        const renderBlock = (b, drawFunc) => {
            let color = flashMode ? randomColor() : b.color;
            
            // Chaos: Rainbow Edges
            if (rainbowEdges) { color = `hsl(${(Date.now()/5 + b.x) % 360}, 100%, 50%)`; }

            if (neonMode) { ctx.shadowBlur = 10; ctx.shadowColor = color; }
            
            // Chaos: Invert Colors (Draw override)
            if (invertColors) { color = '#000000'; ctx.fillStyle = '#ffffff'; }

            if (outlineOnly) { ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.shadowBlur = 0; drawFunc(true, glitchOffsetX, glitchOffsetY); }
            else if (wireframeMode) { ctx.strokeStyle = color; ctx.lineWidth = 1; drawFunc(true, glitchOffsetX, glitchOffsetY); }
            else { ctx.fillStyle = color; drawFunc(false, glitchOffsetX, glitchOffsetY); }
        };
        
        rectangles.forEach((b) => {
            renderBlock(b, (isOutline, ox, oy) => {
                if (isOutline) ctx.strokeRect(b.x + ox, b.y + oy, b.displayW, b.displayH);
                else ctx.fillRect(b.x + ox, b.y + oy, b.displayW, b.displayH);
            });
        });
        circles.forEach((b) => {
            renderBlock(b, (isOutline, ox, oy) => {
                ctx.beginPath(); ctx.arc(b.x + b.displayW/2 + ox, b.y + b.displayH/2 + oy, b.displayW/2, 0, Math.PI*2);
                if (isOutline) ctx.stroke(); else ctx.fill();
            });
        });
        triangles.forEach((b) => {
            renderBlock(b, (isOutline, ox, oy) => {
                ctx.beginPath(); ctx.moveTo(b.x + b.displayW/2 + ox, b.y + oy); ctx.lineTo(b.x + ox, b.y + b.displayH + oy); ctx.lineTo(b.x + b.displayW + ox, b.y + b.displayH + oy); ctx.closePath();
                if (isOutline) ctx.stroke(); else ctx.fill();
            });
        });
        
        ctx.globalAlpha = 1; ctx.shadowBlur = 0; ctx.globalCompositeOperation = 'source-over';
        
        dynamites.forEach((d) => {
            if (d.exploded) return; ctx.fillStyle = '#8B4513'; ctx.fillRect(d.x + 5, d.y + 10, d.w - 10, d.h - 20); ctx.fillStyle = d.color; ctx.fillRect(d.x, d.y, d.w, d.h - 20);
            if (d.timer < 60) { ctx.fillStyle = '#FFFF00'; ctx.fillRect(d.x + d.w/2 - 2, d.y - 10, 4, 10); }
            ctx.fillStyle = d.timer < 60 ? '#ffff00' : '#000000'; ctx.font = 'bold 12px Arial'; ctx.fillText(Math.ceil(d.timer/60), d.x + d.w/2 - 5, d.y + d.h/2 + 5);
        });
    }
    
    // Performance Monitor
    let lastPerfUpdate = performance.now(); let fps = 60;
    function updatePerformanceMonitor() {
        const now = performance.now();
        if (now - lastPerfUpdate >= 1000) {
            fps = Math.round(1000 / (now - lastPerfUpdate) * frameCount);
            frameCount = 0; lastPerfUpdate = now;
            if (fps < 20 && blocks.length > 50) console.warn(`Low FPS: ${fps}. Auto-adjusting.`);
            if (fps < 20) { performanceSettings.collisionCheckInterval = Math.min(4, performanceSettings.collisionCheckInterval + 1); performanceSettings.particleUpdateInterval = Math.min(3, performanceSettings.particleUpdateInterval + 1); performanceSettings.renderInterval = Math.min(2, performanceSettings.renderInterval + 1); }
            else if (fps > 55) { performanceSettings.collisionCheckInterval = 2; performanceSettings.particleUpdateInterval = 2; performanceSettings.renderInterval = 1; }
        }
    }

    // === WELCOME SCREEN ===
    const welcomeScreen = document.createElement('div');
    Object.assign(welcomeScreen.style, {
        position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', background: 'rgba(0, 0, 0, 0.9)', zIndex: '99999',
        display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        backdropFilter: 'blur(5px)', transition: 'opacity 0.3s'
    });
    const box = document.createElement('div');
    Object.assign(box.style, { width: '400px', padding: '30px', borderRadius: '10px', background: 'linear-gradient(135deg, #1a1a1a, #0a0a0a)', border: '2px solid #8a2be2', boxShadow: '0 0 30px #8a2be2', textAlign: 'center', color: '#fff' });
    const title = document.createElement('h2'); title.textContent = "X-PHYSICS ENGINE"; title.style = "margin: 0 0 10px 0; color: #8a2be2; font-size: 28px; text-transform: uppercase; letter-spacing: 2px;";
    const subtitle = document.createElement('p'); subtitle.textContent = "Interactive Physics & Audio Visuals"; subtitle.style = "margin: 0 0 20px 0; color: #ccc; font-size: 14px;";
    const info = document.createElement('div'); info.innerHTML = " Voice/Mic Section (Pitch, Shake)<br> <b>NEW:</b> Search & Macros (Snippet Integration)<br> Magnetize & Particle Systems<br> Reset All Functionality"; info.style = "background: #111; padding: 10px; border-radius: 5px; font-size: 12px; color: #aaa; margin-bottom: 20px; text-align: left; border: 1px solid #333; line-height: 1.5;";
    const startBtn = document.createElement('button'); startBtn.textContent = "INITIALIZE / START"; Object.assign(startBtn.style, { width: '100%', padding: '12px', fontSize: '16px', fontWeight: 'bold', background: 'linear-gradient(90deg, #8a2be2, #5e1bc0)', border: 'none', color: '#fff', cursor: 'pointer', borderRadius: '5px', transition: 'transform 0.1s, filter 0.2s' });
    const status = document.createElement('div'); status.textContent = "Waiting for user interaction..."; status.style = "margin-top: 10px; font-size: 11px; color: #555;";
    startBtn.onmouseenter = () => { startBtn.style.transform = "scale(1.02)"; startBtn.style.filter = "brightness(1.2)"; };
    startBtn.onmouseleave = () => { startBtn.style.transform = "scale(1)"; startBtn.style.filter = "brightness(1)"; };
    startBtn.onclick = async () => {
        status.textContent = "Activating Audio & Physics..."; status.style.color = "#0f0"; status.style.fontWeight = "bold";
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        welcomeScreen.style.opacity = 0;
        setTimeout(() => {
            welcomeScreen.style.display = 'none';
            canvas.style.opacity = 1;
            gui.style.opacity = 1; gui.style.pointerEvents = 'all';
            setTimeout(() => { startAudio(); }, 500);
            console.log("System Unlocked.");
        }, 300);
    };
    box.appendChild(title); box.appendChild(subtitle); box.appendChild(info); box.appendChild(startBtn); box.appendChild(status);
    welcomeScreen.appendChild(box); document.body.appendChild(welcomeScreen);

    // === ANIMATION LOOPS ===
    function animate() {
        update();
        draw();
        updatePerformanceMonitor();
        requestAnimationFrame(animate);
    }
    animate();
})();
