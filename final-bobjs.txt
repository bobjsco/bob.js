(() => {
  // === Enhanced Audio System ===
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();

  function playSound(type) {
    try {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      switch (type) {
        case 'bounce':
          oscillator.frequency.value = 200 + Math.random() * 50;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.1);
          break;
        case 'collision':
          oscillator.frequency.value = 150 + Math.random() * 30;
          oscillator.type = 'square';
          gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.15);
          break;
        case 'explosion':
          oscillator.frequency.value = 50 + Math.random() * 20;
          oscillator.type = 'sawtooth';
          gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.5);
          break;
        case 'click':
          oscillator.frequency.value = 800 + Math.random() * 100;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.05);
          break;
        case 'whoosh':
          oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(
            100 + Math.random() * 50,
            audioCtx.currentTime + 0.3
          );
          oscillator.type = 'triangle';
          gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.3);
          break;
        case 'rolling':
          oscillator.frequency.value = 60 + Math.random() * 20;
          oscillator.type = 'triangle';
          gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.1);
          break;
      }
    } catch (e) {
      // Audio might be blocked, but that's okay
    }
  }

  // === Setup canvas ===
  const canvas = document.createElement('canvas');
  Object.assign(canvas.style, {
    position: 'fixed',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    zIndex: 1,
    touchAction: 'none'
  });
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');
  canvas.width = innerWidth;
  canvas.height = innerHeight;

  // === OPTIMIZATION: Spatial Grid for Collision Detection ===
  class SpatialGrid {
    constructor(cellSize) {
      this.cellSize = cellSize;
      this.cells = new Map();
    }
   
    clear() {
      this.cells.clear();
    }
   
    getKey(x, y) {
      const cellX = Math.floor(x / this.cellSize);
      const cellY = Math.floor(y / this.cellSize);
      return `${cellX},${cellY}`;
    }
   
    addObject(obj) {
      const keys = this.getKeysForObject(obj);
      keys.forEach(key => {
        if (!this.cells.has(key)) {
          this.cells.set(key, []);
        }
        this.cells.get(key).push(obj);
      });
    }
   
    getKeysForObject(obj) {
      const keys = new Set();
      const startX = Math.floor(obj.x / this.cellSize);
      const startY = Math.floor(obj.y / this.cellSize);
      const endX = Math.floor((obj.x + obj.w) / this.cellSize);
      const endY = Math.floor((obj.y + obj.h) / this.cellSize);
     
      for (let x = startX; x <= endX; x++) {
        for (let y = startY; y <= endY; y++) {
          keys.add(`${x},${y}`);
        }
      }
      return Array.from(keys);
    }
   
    getNearbyObjects(obj) {
      const keys = this.getKeysForObject(obj);
      const nearby = new Set();
     
      keys.forEach(key => {
        const objects = this.cells.get(key);
        if (objects) {
          objects.forEach(o => {
            if (o !== obj) nearby.add(o);
          });
        }
      });
     
      return Array.from(nearby);
    }
  }

  // === Physics constants (base) ===
  let gravity = 0.6;
  let gravityDir = 1;
  let friction = 0.85;
  let wallBounce = 0.75;
  let restitution = 0.8;
  let collisionsEnabled = true;
  let blockSize = 100;
  let airResistance = 0.999;
  let angularDamping = 0.98;
  let magnetStrength = 3;

  // === OPTIMIZATION: Performance settings ===
  const performanceSettings = {
    maxShapes: 999999, // No limits
    maxParticles: 999999, // No limits
    spatialGridSize: 150, // Larger grid cells = fewer checks
    collisionCheckInterval: 2, // Check collisions every N frames
    particleUpdateInterval: 2, // Update particles every N frames
    renderInterval: 1 // Render every N frames
  };

  // === Unified Physics Settings (for UI + presets) ===
  let physicsSettings = {
    gravity,
    airResistance,
    angularDamping,
    restitution,
    friction,
    wallBounce,
    magnetStrength: magnetStrength * 50, // UI scale; mapped back in applyPhysicsSettings
    collisionEnergyLoss: 0.15,
    angularVelocityTransfer: 0.5,
    particleEmissionRate: 5,
    particleLife: 100,
    particleSize: 3,
    explosionParticles: 20,
    trailLength: 10,
    shadowBlur: 15,
    shadowOpacity: 0.5,
    trailOpacity: 0.3,
    glowIntensity: 1.0,
    timeScale: 1.0
  };

  function applyPhysicsSettings() {
    gravity = physicsSettings.gravity;
    airResistance = physicsSettings.airResistance;
    angularDamping = physicsSettings.angularDamping;
    restitution = physicsSettings.restitution;
    friction = physicsSettings.friction;
    wallBounce = physicsSettings.wallBounce;
    magnetStrength = physicsSettings.magnetStrength / 50;
  }

  // Initialize to Normal Bounciness by default (no energy loss)
  physicsSettings.restitution = 1.0;
  physicsSettings.wallBounce = 1.0;
  physicsSettings.collisionEnergyLoss = 0.0;
  applyPhysicsSettings();

  // === Target size for shrink/grow modes ===
  let targetSize = { width: blockSize, height: blockSize };

  // === Effect flags ===
  let rainbowMode = false;
  let shrinkMode = false;
  let growMode = false;
  let trailMode = false;
  let flashMode = false;
  let colorCycle = false;
  let randomFrameColors = false;
  let gravityWave = false;
  let gravitySpin = false;
  let magnetize = false;
  let magnetInvert = false;
  let centerPull = false;
  let verticalMovement = true;
  let horizontalMovement = true;
  let slowMo = 1;
  let rotateMode = false;
  let tornadoMode = false;
  let sizeWaveMode = false;
  let antiGravityMode = false;

  // === Color Pulsing System ===
  let colorPulseMode = false;
  let menuPulseMode = false;
  let pulseColor1 = '#ff595e';
  let pulseColor2 = '#1982c4';
  let pulsePhase = 0;
  let menuPulsePhase = 0;
  let pulseSpeed = 0.05;
  let menuPulseSpeed = 0.03;

  // === Particle Effects System ===
  let flamingParticlesActive = false;
  let mouseTrailActive = false;
  let snowfallActive = false;
  let sparklerActive = false;
  let starfieldActive = false;
  let rainActive = false;
  let bubblesActive = false;
  let fireworksActive = false;
  let smokeTrailActive = false;
  let electricityActive = false;
  let pixelDustActive = false;
  let cosmicWindActive = false;
  let auroraActive = false;
  let plasmaActive = false;
  let nebulaDriftActive = false;

  // === Illusion flags ===
  let illusionsActive = {
    spiral: false,
    breathingGrid: false,
    waveTunnel: false,
    vortex: false,
    orbitRing: false,
    checkerSpin: false,
    flipStrip: false,
    zoomPulse: false,
    swirlField: false,
    hypnoHue: false
  };

  // === Sound cooldown system ===
  const soundCooldowns = {
    bounce: 0,
    collision: 0,
    rolling: 0
  };
  const SOUND_COOLDOWN_TIME = 100;

  const defaultSettings = {
    gravity: 0.6,
    friction: 0.85,
    wallBounce: 0.75,
    restitution: 0.8,
    blockSize: 100,
    gravityDir: 1,
    magnetStrength: 3
  };

  const colors = ['#ff595e', '#8ac926', '#1982c4', '#ffca3a', '#6a4c93'];
  const shapes = ['rectangle', 'circle', 'triangle'];

  // === OPTIMIZATION: Create spatial grid ===
  const spatialGrid = new SpatialGrid(performanceSettings.spatialGridSize);
  let frameCount = 0;

  // === Block factory ===
  function makeBlock(x, y, color = randomColor(), shape = randomShape()) {
    const mass = 1;
    return {
      x,
      y,
      w: blockSize,
      h: blockSize,
      color,
      vx: (Math.random() - 0.5) * 2,
      vy: 0,
      isDragging: false,
      shape,
      mass,
      rotation: 0,
      rotationSpeed: (Math.random() - 0.5) * 0.1,
      angularVelocity: 0,
      displayW: blockSize,
      displayH: blockSize,
      elasticity: restitution,
      friction,
      momentOfInertia: (mass * (blockSize * blockSize + blockSize * blockSize)) / 12,
      trail: [],
      maxTrailLength: 20
    };
  }

  // Start with exactly 3 shapes
  const blocks = [
    makeBlock(200, 100, colors[0], 'rectangle'),
    makeBlock(360, 100, colors[1], 'circle'),
    makeBlock(520, 100, colors[2], 'triangle')
  ];

  const activeCollisions = new Set();
  const dynamites = [];
  const particles = [];
  const effectParticles = [];

  // Mouse positions
  let mouseX = 0;
  let mouseY = 0;
  let lastMouseX = 0;
  let lastMouseY = 0;
  let prevMouseX = 0;
  let prevMouseY = 0;

  function makeDynamite(x, y) {
    return {
      x,
      y,
      vx: 0,
      vy: 0,
      w: 20,
      h: 50,
      timer: 180,
      exploded: false,
      color: 'red',
      isDragging: false
    };
  }

  // === OPTIMIZATION: Particle pooling ===
  const particlePool = [];
 
  function makeParticle(x, y, color) {
    // Try to reuse from pool
    if (particlePool.length > 0) {
      const particle = particlePool.pop();
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random() - 0.5) * 15;
      particle.vy = (Math.random() - 0.5) * 15;
      particle.life = 100;
      particle.color = color;
      particle.size = Math.random() * 6 + 2;
      particle.gravity = 0.2;
      particle.airResistance = 0.98;
      return particle;
    }
   
    // Create new if pool is empty
    return {
      x,
      y,
      vx: (Math.random() - 0.5) * 15,
      vy: (Math.random() - 0.5) * 15,
      life: 100,
      color,
      size: Math.random() * 6 + 2,
      gravity: 0.2,
      airResistance: 0.98
    };
  }

  // === Effect particles factory ===
  function makeEffectParticle(type, x, y) {
    const base = { x, y, life: 100, maxLife: 100, size: 2, type };

    switch (type) {
      case 'flame':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 3,
          vy: -Math.random() * 4 - 2,
          color: `hsl(${Math.random() * 60},100%,${50 + Math.random() * 30}%)`,
          size: Math.random() * 10 + 4,
          life: 80,
          gravity: -0.1
        };
      case 'mouseTrail':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 1,
          vy: (Math.random() - 0.5) * 1,
          color: `hsl(${Math.random() * 360},70%,60%)`,
          size: Math.random() * 8 + 3,
          life: 40,
          gravity: 0
        };
      case 'snow':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 0.8,
          vy: Math.random() * 1.5 + 0.5,
          color: '#ffffff',
          size: Math.random() * 5 + 2,
          life: 400,
          gravity: 0.05
        };
      case 'sparkle':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          color: `hsl(${Math.random() * 60 + 40},100%,80%)`,
          size: Math.random() * 4 + 1,
          life: 50,
          twinkle: Math.random() * Math.PI * 2,
          gravity: 0
        };
      case 'star':
        return {
          ...base,
          vx: 0,
          vy: Math.random() * 0.8 + 0.2,
          color: `hsl(${Math.random() * 60 + 200},70%,80%)`,
          size: Math.random() * 3 + 1,
          life: 600,
          gravity: 0.01
        };
      case 'rain':
        return {
          ...base,
          vx: Math.random() * 3 - 1,
          vy: Math.random() * 10 + 8,
          color: 'rgba(100,150,255,0.7)',
          size: Math.random() * 3 + 1,
          life: 200,
          gravity: 0.3
        };
      case 'bubble':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 1.5,
          vy: -Math.random() * 3 - 1,
          color: `hsla(${Math.random() * 60 + 180},50%,80%,0.3)`,
          size: Math.random() * 18 + 7,
          life: 250,
          float: Math.random() * Math.PI * 2,
          gravity: -0.05
        };
      case 'firework':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 12,
          vy: (Math.random() - 0.5) * 12,
          color: `hsl(${Math.random() * 360},100%,60%)`,
          size: Math.random() * 5 + 2,
          life: 100,
          gravity: 0.15,
          airResistance: 0.97
        };
      case 'smoke':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 1.5,
          vy: -Math.random() * 3 - 1,
          color: `rgba(100,100,100,${0.5 - Math.random() * 0.3})`,
          size: Math.random() * 12 + 6,
          life: 120,
          gravity: -0.02,
          airResistance: 0.95
        };
      case 'electric':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          color: `hsl(${Math.random() * 60 + 180},100%,80%)`,
          size: Math.random() * 4 + 1,
          life: 25,
          intensity: Math.random(),
          gravity: 0,
          airResistance: 0.9
        };
      case 'pixelDust':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          color: `hsl(${Math.random() * 360},80%,70%)`,
          size: 2,
          life: 150,
          gravity: 0.05
        };
      case 'cosmic':
        return {
          ...base,
          vx: Math.random() * 4 + 2,
          vy: (Math.random() - 0.5) * 1.5,
          color: `hsl(${Math.random() * 60 + 280},70%,60%)`,
          size: Math.random() * 4 + 1,
          life: 250,
          gravity: 0.02
        };
      case 'aurora':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 0.8,
          color: `hsl(${Math.random() * 120 + 120},60%,70%)`,
          size: Math.random() * 10 + 5,
          life: 200,
          wave: Math.random() * Math.PI * 2,
          gravity: 0,
          airResistance: 0.98
        };
      case 'plasma':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 0.5) * 5,
          color: `hsl(${Math.random() * 60 + 300},80%,70%)`,
          size: Math.random() * 8 + 4,
          life: 80,
          energy: Math.random(),
          gravity: 0,
          airResistance: 0.96
        };
      case 'nebula':
        return {
          ...base,
          vx: (Math.random() - 0.5) * 0.8,
          vy: (Math.random() - 0.5) * 0.8,
          color: `hsl(${Math.random() * 180 + 200},60%,50%)`,
          size: Math.random() * 15 + 10,
          life: 350,
          drift: Math.random() * Math.PI * 2,
          gravity: 0,
          airResistance: 0.99
        };
      default:
        return { ...base, vx: 0, vy: 0, color: '#ffffff' };
    }
  }

  function updateEffectParticles() {
    // Skip particle updates on some frames for performance
    if (frameCount % performanceSettings.particleUpdateInterval !== 0) return;
   
    if (flamingParticlesActive) {
      for (let i = 0; i < 4; i++) {
        const particle = makeEffectParticle('flame', Math.random() * canvas.width, canvas.height + 10);
        effectParticles.push(particle);
      }
    }
    if (mouseTrailActive) {
      const particle = makeEffectParticle('mouseTrail', mouseX, mouseY);
      effectParticles.push(particle);
    }
    if (snowfallActive) {
      for (let i = 0; i < 3; i++) {
        const particle = makeEffectParticle('snow', Math.random() * canvas.width, -10);
        effectParticles.push(particle);
      }
    }
    if (sparklerActive) {
      for (let i = 0; i < 6; i++) {
        const particle = makeEffectParticle(
          'sparkle',
          mouseX + (Math.random() - 0.5) * 40,
          mouseY + (Math.random() - 0.5) * 40
        );
        effectParticles.push(particle);
      }
    }
    if (starfieldActive) {
      const particle = makeEffectParticle('star', Math.random() * canvas.width, -10);
      effectParticles.push(particle);
    }
    if (rainActive) {
      for (let i = 0; i < 6; i++) {
        const particle = makeEffectParticle('rain', Math.random() * canvas.width, -10);
        effectParticles.push(particle);
      }
    }
    if (bubblesActive) {
      const particle = makeEffectParticle('bubble', Math.random() * canvas.width, canvas.height + 10);
      effectParticles.push(particle);
    }
    if (fireworksActive && Math.random() < 0.15) {
      const ex = Math.random() * canvas.width;
      const ey = Math.random() * canvas.height * 0.7;
      for (let i = 0; i < 20; i++) {
        const particle = makeEffectParticle('firework', ex, ey);
        effectParticles.push(particle);
      }
    }
    if (smokeTrailActive) {
      const particle = makeEffectParticle('smoke', mouseX, mouseY);
      effectParticles.push(particle);
    }
    if (electricityActive) {
      for (let i = 0; i < 4; i++) {
        const particle = makeEffectParticle('electric', Math.random() * canvas.width, Math.random() * canvas.height);
        effectParticles.push(particle);
      }
    }
    if (pixelDustActive) {
      for (let i = 0; i < 3; i++) {
        const particle = makeEffectParticle(
          'pixelDust',
          Math.random() * canvas.width,
          Math.random() * canvas.height
        );
        effectParticles.push(particle);
      }
    }
    if (cosmicWindActive) {
      const particle = makeEffectParticle('cosmic', -10, Math.random() * canvas.height);
      effectParticles.push(particle);
    }
    if (auroraActive) {
      const particle = makeEffectParticle(
        'aurora',
        Math.random() * canvas.width,
        Math.random() * canvas.height * 0.3
      );
      effectParticles.push(particle);
    }
    if (plasmaActive) {
      for (let i = 0; i < 3; i++) {
        const particle = makeEffectParticle('plasma', Math.random() * canvas.width, Math.random() * canvas.height);
        effectParticles.push(particle);
      }
    }
    if (nebulaDriftActive) {
      const particle = makeEffectParticle('nebula', Math.random() * canvas.width, Math.random() * canvas.height);
      effectParticles.push(particle);
    }

    for (let i = effectParticles.length - 1; i >= 0; i--) {
      const p = effectParticles[i];
      if (p.gravity !== undefined) p.vy += p.gravity;
      if (p.airResistance !== undefined) {
        p.vx *= p.airResistance;
        p.vy *= p.airResistance;
      }
      p.x += p.vx;
      p.y += p.vy;

      if (p.type === 'bubble') {
        p.float += 0.1;
        p.x += Math.sin(p.float) * 0.8;
      }
      if (p.type === 'sparkle') p.twinkle += 0.3;
      if (p.type === 'aurora') {
        p.wave += 0.15;
        p.x += Math.sin(p.wave) * 0.5;
        p.y += Math.cos(p.wave) * 0.2;
      }
      if (p.type === 'nebula') {
        p.drift += 0.05;
        p.x += Math.cos(p.drift) * 0.3;
        p.y += Math.sin(p.drift) * 0.3;
      }
      if (p.type === 'electric') {
        p.vx += (Math.random() - 0.5) * 2;
        p.vy += (Math.random() - 0.5) * 2;
      }

      p.life--;
      if (
        p.life <= 0 ||
        p.y > canvas.height + 50 ||
        p.x > canvas.width + 50 ||
        p.x < -50
      ) {
        // Return to pool instead of deleting
        if (particlePool.length < 100) {
          particlePool.push(p);
        }
        effectParticles.splice(i, 1);
      }
    }
  }

  function randomColor() {
    return colors[Math.floor(Math.random() * colors.length)];
  }

  function randomShape() {
    return shapes[Math.floor(Math.random() * shapes.length)];
  }

  function interpolateColor(color1, color2, factor) {
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);
    const r = Math.round(c1.r + (c2.r - c1.r) * factor);
    const g = Math.round(c1.g + (c2.g - c1.g) * factor);
    const b = Math.round(c1.b + (c2.b - c1.b) * factor);
    return `rgb(${r}, ${g}, ${b})`;
  }

  function hexToRgb(hex) {
    const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return res
      ? {
          r: parseInt(res[1], 16),
          g: parseInt(res[2], 16),
          b: parseInt(res[3], 16)
        }
      : { r: 255, g: 255, b: 255 };
  }

  // === Menu base ===
  const menu = document.createElement('div');
  Object.assign(menu.style, {
    position: 'fixed',
    top: '50px',
    left: '50px',
    background: 'black',
    border: '2px solid #00ff00',
    padding: '10px',
    borderRadius: '10px',
    zIndex: 10000,
    display: 'flex',
    flexDirection: 'column',
    gap: '8px',
    color: '#00ff00',
    maxHeight: '80vh',
    overflowY: 'auto',
    fontSize: '14px'
  });
  document.body.appendChild(menu);

  const titleBar = document.createElement('div');
  titleBar.innerText = "Bob's Physics Menu";
  Object.assign(titleBar.style, {
    fontWeight: 'bold',
    cursor: 'grab',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  });
  menu.appendChild(titleBar);

  const closeButton = document.createElement('div');
  closeButton.innerText = '✖';
  closeButton.style.cursor = 'pointer';
  closeButton.onclick = () => {
    menu.style.display = 'none';
  };
  titleBar.appendChild(closeButton);

  // === Menu drag ===
  let draggingMenu = false;
  let offsetX = 0;
  let offsetY = 0;

  titleBar.addEventListener('mousedown', (e) => {
    draggingMenu = true;
    offsetX = e.clientX - menu.offsetLeft;
    offsetY = e.clientY - menu.offsetTop;
    titleBar.style.cursor = 'grabbing';
  });

  window.addEventListener('mousemove', (e) => {
    if (!draggingMenu) return;
    menu.style.left = e.clientX - offsetX + 'px';
    menu.style.top = e.clientY - offsetY + 'px';
  });

  window.addEventListener('mouseup', () => {
    draggingMenu = false;
    titleBar.style.cursor = 'grab';
  });

  // === UI helpers ===
  function createButton(text, onClick) {
    const btn = document.createElement('button');
    btn.innerText = text;
    Object.assign(btn.style, {
      background: 'black',
      color: '#00ff00',
      border: '2px solid #00ff00',
      padding: '5px 10px',
      cursor: 'pointer',
      borderRadius: '5px',
      fontSize: '13px'
    });
    btn.onmouseover = () => {
      btn.style.background = '#003300';
    };
    btn.onmouseout = () => {
      btn.style.background = 'black';
    };
    btn.onclick = () => {
      playSound('click');
      onClick();
    };
    return btn;
  }

  function createSlider(labelText, min, max, step, value, onInput) {
    const container = document.createElement('div');
    const label = document.createElement('label');
    label.innerText = `${labelText}: ${value}`;
    const input = document.createElement('input');
    input.type = 'range';
    input.min = min;
    input.max = max;
    input.step = step;
    input.value = value;
    input.oninput = (e) => {
      const val = parseFloat(e.target.value);
      label.innerText = `${labelText}: ${val.toFixed(2)}`;
      onInput(val);
    };
    container.appendChild(label);
    container.appendChild(input);
    return { container, input, label };
  }

  // === Core controls ===
  const spawnShapeBtn = createButton('Spawn Shape', () => {
    blocks.push(makeBlock(Math.random() * (canvas.width - blockSize), 0));
    playSound('whoosh');
  });
  const removeShapesBtn = createButton('Remove All Shapes', () => {
    blocks.splice(0, blocks.length);
  });
  const teleportBtn = createButton('Teleport Random', () => {
    blocks.forEach((b) => {
      b.x = Math.random() * (canvas.width - b.w);
      b.y = Math.random() * (canvas.height - b.h);
      b.vx = (Math.random() - 0.5) * 5;
      b.vy = (Math.random() - 0.5) * 5;
    });
    playSound('whoosh');
  });
  const toggleCollisionsBtn = createButton('Toggle Collisions', () => {
    collisionsEnabled = !collisionsEnabled;
  });

  let currentShapeIndex = 0;
  const toggleShapesBtn = createButton('Toggle Shapes', () => {
    currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
    blocks.forEach((b) => {
      b.shape = shapes[currentShapeIndex];
    });
  });

  const gravitySlider = createSlider('Gravity', 0, 3, 0.1, physicsSettings.gravity, (v) => {
    physicsSettings.gravity = v;
    applyPhysicsSettings();
  });

  const frictionSlider = createSlider('Friction', 0, 1, 0.05, physicsSettings.friction, (v) => {
    physicsSettings.friction = v;
    applyPhysicsSettings();
  });

  menu.appendChild(spawnShapeBtn);
  menu.appendChild(removeShapesBtn);
  menu.appendChild(teleportBtn);
  menu.appendChild(toggleCollisionsBtn);
  menu.appendChild(toggleShapesBtn);
  menu.appendChild(gravitySlider.container);
  menu.appendChild(frictionSlider.container);

  // === Color spectrum helper ===
  function createColorSpectrum(label, initialColor, callback) {
    const spectrum = document.createElement('div');
    spectrum.className = 'color-spectrum';

    Object.assign(spectrum.style, {
      position: 'fixed',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      background: 'rgba(0,0,0,0.95)',
      border: '2px solid #00ff00',
      borderRadius: '10px',
      padding: '20px',
      zIndex: 10001,
      display: 'none',
      boxShadow: '0 0 20px rgba(0,255,0,0.5)',
      flexDirection: 'column',
      gap: '10px'
    });

    const spectrumLabel = document.createElement('div');
    spectrumLabel.textContent = label;
    Object.assign(spectrumLabel.style, {
      color: '#00ff00',
      textAlign: 'center',
      marginBottom: '10px',
      fontWeight: 'bold'
    });

    const preview = document.createElement('div');
    Object.assign(preview.style, {
      width: '50px',
      height: '50px',
      border: '2px solid #00ff00',
      borderRadius: '5px',
      margin: '10px auto',
      backgroundColor: initialColor
    });

    const spectrumCanvas = document.createElement('canvas');
    Object.assign(spectrumCanvas.style, {
      border: '1px solid #00ff00',
      borderRadius: '5px',
      cursor: 'crosshair',
      margin: '10px 0'
    });
    spectrumCanvas.width = 300;
    spectrumCanvas.height = 200;

    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    Object.assign(closeBtn.style, {
      background: '#003300',
      color: '#00ff00',
      border: '1px solid #00ff00',
      padding: '5px 10px',
      cursor: 'pointer',
      borderRadius: '5px',
      margin: '5px auto'
    });

    spectrum.appendChild(spectrumLabel);
    spectrum.appendChild(preview);
    spectrum.appendChild(spectrumCanvas);
    spectrum.appendChild(closeBtn);
    document.body.appendChild(spectrum);

    const sctx = spectrumCanvas.getContext('2d');
    for (let x = 0; x < spectrumCanvas.width; x++) {
      for (let y = 0; y < spectrumCanvas.height; y++) {
        const hue = (x / spectrumCanvas.width) * 360;
        const lightness = 100 - (y / spectrumCanvas.height) * 100;
        sctx.fillStyle = `hsl(${hue},100%,${lightness}%)`;
        sctx.fillRect(x, y, 1, 1);
      }
    }

    spectrumCanvas.addEventListener('click', (e) => {
      const rect = spectrumCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const hue = (x / spectrumCanvas.width) * 360;
      const lightness = 100 - (y / spectrumCanvas.height) * 100;
      const selected = `hsl(${hue},100%,${lightness}%)`;

      const rgb = hslToRgb(hue, 100, lightness);
      const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
      preview.style.backgroundColor = selected;
      callback(hex);
    });

    function hslToRgb(h, s, l) {
      s /= 100;
      l /= 100;
      const k = (n) => (n + h / 30) % 12;
      const a = s * Math.min(l, 1 - l);
      const f = (n) =>
        l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
      return {
        r: Math.round(255 * f(0)),
        g: Math.round(255 * f(8)),
        b: Math.round(255 * f(4))
      };
    }

    function rgbToHex(r, g, b) {
      return (
        '#' +
        ((1 << 24) + (r << 16) + (g << 8) + b)
          .toString(16)
          .slice(1)
      );
    }

    closeBtn.onclick = () => {
      spectrum.style.display = 'none';
    };

    return spectrum;
  }
    // === Color Controls Tab ===
  const colorTabHeader = document.createElement('div');
  colorTabHeader.innerText = 'Color Controls ▼';
  colorTabHeader.style.cursor = 'pointer';
  menu.appendChild(colorTabHeader);

  const colorTab = document.createElement('div');
  Object.assign(colorTab.style, { display: 'none', flexDirection: 'column', gap: '5px' });
  menu.appendChild(colorTab);

  const color1Spectrum = createColorSpectrum('Select Color 1', pulseColor1, (color) => {
    pulseColor1 = color;
    color1Btn.style.background = color;
    color1Btn.style.color = '#fff';
  });

  const color2Spectrum = createColorSpectrum('Select Color 2', pulseColor2, (color) => {
    pulseColor2 = color;
    color2Btn.style.background = color;
    color2Btn.style.color = '#fff';
  });

  const color1Btn = createButton('Color 1', () => {
    color1Spectrum.style.display = 'block';
  });
  color1Btn.style.background = pulseColor1;
  color1Btn.style.color = '#fff';

  const color2Btn = createButton('Color 2', () => {
    color2Spectrum.style.display = 'block';
  });
  color2Btn.style.background = pulseColor2;
  color2Btn.style.color = '#fff';

  const pulseSpeedSlider = createSlider('Pulse Speed', 0.0025, 0.2, 0.0025, pulseSpeed, (v) => {
    pulseSpeed = v;
  });

  const menuPulseSpeedSlider = createSlider(
    'Menu Pulse Speed',
    0.0025,
    0.2,
    0.025,
    menuPulseSpeed,
    (v) => {
      menuPulseSpeed = v;
    }
  );

  const togglePulseBtn = createButton('Toggle Shape Pulse', () => {
    colorPulseMode = !colorPulseMode;
    if (!colorPulseMode) {
      blocks.forEach((b, i) => {
        b.color = colors[i % colors.length];
      });
    }
  });

  const toggleMenuPulseBtn = createButton('Toggle Menu Pulse', () => {
    menuPulseMode = !menuPulseMode;
    if (!menuPulseMode) {
      menu.style.background = 'black';
      menu.style.color = '#00ff00';
      menu.style.borderColor = '#00ff00';

      const buttons = menu.querySelectorAll('button');
      buttons.forEach((btn) => {
        if (!btn.textContent.includes('Color 1') && !btn.textContent.includes('Color 2')) {
          btn.style.background = 'black';
          btn.style.color = '#00ff00';
          btn.style.borderColor = '#00ff00';
        }
      });

      const labels = menu.querySelectorAll('label, div');
      labels.forEach((label) => {
        if (!label.textContent.includes('✖')) {
          label.style.color = '#00ff00';
        }
      });
    }
  });

  colorTab.appendChild(color1Btn);
  colorTab.appendChild(color2Btn);
  colorTab.appendChild(pulseSpeedSlider.container);
  colorTab.appendChild(menuPulseSpeedSlider.container);
  colorTab.appendChild(togglePulseBtn);
  colorTab.appendChild(toggleMenuPulseBtn);

  colorTabHeader.addEventListener('click', () => {
    colorTab.style.display = colorTab.style.display === 'none' ? 'flex' : 'none';
    colorTabHeader.innerText =
      colorTab.style.display === 'none' ? 'Color Controls ▼' : 'Color Controls ▲';
  });

  // === Particle Effects Tab ===
  const particleTabHeader = document.createElement('div');
  particleTabHeader.innerText = 'Particle Effects ▼';
  particleTabHeader.style.cursor = 'pointer';
  menu.appendChild(particleTabHeader);

  const particleTab = document.createElement('div');
  Object.assign(particleTab.style, { display: 'none', flexDirection: 'column', gap: '5px' });
  menu.appendChild(particleTab);

  const particleButtons = [
    ['Flaming Particles', () => { flamingParticlesActive = !flamingParticlesActive; }],
    ['Mouse Trail', () => { mouseTrailActive = !mouseTrailActive; }],
    ['Snowfall', () => { snowfallActive = !snowfallActive; }],
    ['Sparkler', () => { sparklerActive = !sparklerActive; }],
    ['Starfield', () => { starfieldActive = !starfieldActive; }],
    ['Rain', () => { rainActive = !rainActive; }],
    ['Bubbles', () => { bubblesActive = !bubblesActive; }],
    ['Fireworks', () => { fireworksActive = !fireworksActive; }],
    ['Smoke Trail', () => { smokeTrailActive = !smokeTrailActive; }],
    ['Electricity', () => { electricityActive = !electricityActive; }],
    ['Pixel Dust', () => { pixelDustActive = !pixelDustActive; }],
    ['Cosmic Wind', () => { cosmicWindActive = !cosmicWindActive; }],
    ['Aurora', () => { auroraActive = !auroraActive; }],
    ['Plasma', () => { plasmaActive = !plasmaActive; }],
    ['Nebula Drift', () => { nebulaDriftActive = !nebulaDriftActive; }],
    ['Clear All Effects', () => {
      flamingParticlesActive = mouseTrailActive = snowfallActive = sparklerActive =
      starfieldActive = rainActive = bubblesActive = fireworksActive = smokeTrailActive =
      electricityActive = pixelDustActive = cosmicWindActive = auroraActive =
      plasmaActive = nebulaDriftActive = false;
      effectParticles.splice(0, effectParticles.length);
    }]
  ];

  particleButtons.forEach(([n, f]) => {
    particleTab.appendChild(createButton(n, f));
  });

  particleTabHeader.addEventListener('click', () => {
    particleTab.style.display = particleTab.style.display === 'none' ? 'flex' : 'none';
    particleTabHeader.innerText =
      particleTab.style.display === 'none' ? 'Particle Effects ▼' : 'Particle Effects ▲';
  });

  // === FUN Tab ===
  const funTabHeader = document.createElement('div');
  funTabHeader.innerText = 'Fun ▼';
  funTabHeader.style.cursor = 'pointer';
  menu.appendChild(funTabHeader);

  const funTab = document.createElement('div');
  Object.assign(funTab.style, { display: 'none', flexDirection: 'column', gap: '5px' });
  menu.appendChild(funTab);

  const funButtons = [
    ['Confetti Explosion', () => {
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      for (let i = 0; i < 60; i++) {
        const particle = makeParticle(cx, cy, randomColor());
        particles.push(particle);
      }
      playSound('explosion');
    }],
    ['Tornado Mode', () => { tornadoMode = !tornadoMode; }],
    ['Rotate Shapes', () => {
      rotateMode = !rotateMode;
      if (rotateMode) {
        blocks.forEach((b) => {
          b.rotationSpeed = (Math.random() - 0.5) * 0.15;
        });
      }
    }],
    ['Size Wave', () => {
      sizeWaveMode = !sizeWaveMode;
      if (!sizeWaveMode) {
        blocks.forEach((b) => {
          b.w = blockSize;
          b.h = blockSize;
          b.displayW = blockSize;
          b.displayH = blockSize;
        });
      }
    }],
    ['Anti-Gravity', () => { antiGravityMode = !antiGravityMode; }],
    ['Black Hole', () => {
      centerPull = true;
      magnetStrength = 8;
      setTimeout(() => {
        centerPull = false;
        magnetStrength = 3;
      }, 4000);
    }],
    ['Shock Wave', () => {
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      blocks.forEach((b) => {
        const dx = (b.x + b.w / 2) - cx;
        const dy = (b.y + b.h / 2) - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const force = 35;
        b.vx = (dx / dist) * force;
        b.vy = (dy / dist) * force;
        b.angularVelocity = (Math.random() - 0.5) * 0.2;
      });
      playSound('explosion');
    }],
    ['Bounce Party', () => {
      blocks.forEach((b) => {
        b.vx = (Math.random() - 0.5) * 30;
        b.vy = (Math.random() - 0.5) * 30;
        b.angularVelocity = (Math.random() - 0.5) * 0.15;
      });
      playSound('whoosh');
    }],
    ['Spawn 5 Shapes', () => {
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          const nb = makeBlock(Math.random() * (canvas.width - blockSize), 0);
          nb.vx = (Math.random() - 0.5) * 5;
          nb.vy = Math.random() * 3;
          blocks.push(nb);
          playSound('whoosh');
        }, i * 100);
      }
    }],
    ['Spawn 20 Shapes', () => {
      for (let i = 0; i < 20; i++) {
        setTimeout(() => {
          const nb = makeBlock(Math.random() * (canvas.width - blockSize), 0);
          nb.vx = (Math.random() - 0.5) * 5;
          nb.vy = Math.random() * 3;
          blocks.push(nb);
          playSound('whoosh');
        }, i * 50);
      }
    }],
    ['Clear Canvas', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }],
    ['Randomize Colors', () => {
      blocks.forEach((b) => { b.color = randomColor(); });
    }],
    ['Big Explosion', () => {
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const blastRadius = 500;
      const blastPower = 80;
      blocks.forEach((b) => {
        const dx = (b.x + b.w / 2) - cx;
        const dy = (b.y + b.h / 2) - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < blastRadius && dist > 0) {
          const force = (1 - dist / blastRadius) * blastPower;
          b.vx = (dx / dist) * force;
          b.vy = (dy / dist) * force - 15;
          b.angularVelocity = (Math.random() - 0.5) * 0.3;
        }
      });
      for (let i = 0; i < 120; i++) {
        const particle = makeParticle(cx, cy, randomColor());
        particles.push(particle);
      }
      playSound('explosion');
    }],
    ['Flip Gravity', () => { gravityDir *= -1; }],
    ['Speed Boost', () => {
      blocks.forEach((b) => {
        b.vx *= 4;
        b.vy *= 4;
        b.angularVelocity *= 2;
      });
      playSound('whoosh');
    }],
    ['Freeze All', () => {
      blocks.forEach((b) => {
        b.vx = 0;
        b.vy = 0;
        b.angularVelocity = 0;
      });
    }],
    ['Randomize Sizes', () => {
      blocks.forEach((b) => {
        b.w = 50 + Math.random() * 120;
        b.h = 50 + Math.random() * 120;
        b.displayW = b.w;
        b.displayH = b.h;
      });
    }],
    ['Rainbow Mode', () => {
      rainbowMode = !rainbowMode;
      if (rainbowMode) colorPulseMode = false;
    }],
    ['Shrink Mode', () => {
      shrinkMode = !shrinkMode;
      if (shrinkMode) {
        targetSize.width = 20;
        targetSize.height = 20;
      } else {
        targetSize.width = blockSize;
        targetSize.height = blockSize;
      }
    }],
    ['Grow Mode', () => {
      growMode = !growMode;
      if (growMode) {
        targetSize.width = 200;
        targetSize.height = 200;
      } else {
        targetSize.width = blockSize;
        targetSize.height = blockSize;
      }
    }],
    ['Trail Mode', () => { trailMode = !trailMode; }],
    ['Flash Mode', () => { flashMode = !flashMode; }],
    ['Color Cycle', () => {
      colorCycle = !colorCycle;
      if (colorCycle) colorPulseMode = false;
    }],
    ['Random Frame Colors', () => { randomFrameColors = !randomFrameColors; }],
    ['Gravity Wave', () => { gravityWave = !gravityWave; }],
    ['Gravity Spin', () => { gravitySpin = !gravitySpin; }],
    ['Magnetize', () => { magnetize = !magnetize; }],
    ['Invert Magnet', () => { magnetInvert = !magnetInvert; }],
    ['Center Pull', () => { centerPull = !centerPull; }],
    ['Toggle Vertical Movement', () => { verticalMovement = !verticalMovement; }],
    ['Toggle Horizontal Movement', () => { horizontalMovement = !horizontalMovement; }],
    ['Slow Motion', () => { slowMo = slowMo === 1 ? 0.1 : 1; }],
    ['Spawn Dynamite', () => {
      const d = makeDynamite(Math.random() * (canvas.width - 50), 0);
      d.vx = (Math.random() - 0.5) * 3;
      dynamites.push(d);
    }],
    ['Reset All Settings', () => {
      gravity = defaultSettings.gravity;
      friction = defaultSettings.friction;
      wallBounce = defaultSettings.wallBounce;
      restitution = defaultSettings.restitution;
      gravityDir = defaultSettings.gravityDir;
      magnetStrength = defaultSettings.magnetStrength;

      rainbowMode = shrinkMode = growMode = trailMode = flashMode = colorCycle =
      randomFrameColors = gravityWave = gravitySpin = magnetize = magnetInvert =
      centerPull = colorPulseMode = menuPulseMode = rotateMode = tornadoMode =
      sizeWaveMode = antiGravityMode = false;

      targetSize = { width: blockSize, height: blockSize };

      flamingParticlesActive = mouseTrailActive = snowfallActive = sparklerActive =
      starfieldActive = rainActive = bubblesActive = fireworksActive = smokeTrailActive =
      electricityActive = pixelDustActive = cosmicWindActive = auroraActive =
      plasmaActive = nebulaDriftActive = false;

      verticalMovement = horizontalMovement = true;
      slowMo = 1;
      collisionsEnabled = true;

      gravitySlider.input.value = gravity;
      gravitySlider.label.innerText = `Gravity: ${gravity.toFixed(2)}`;
      frictionSlider.input.value = friction;
      frictionSlider.label.innerText = `Friction: ${friction.toFixed(2)}`;

      menu.style.background = 'black';
      menu.style.color = '#00ff00';
      menu.style.borderColor = '#00ff00';

      const buttons = menu.querySelectorAll('button');
      buttons.forEach((btn) => {
        if (!btn.textContent.includes('Color 1') && !btn.textContent.includes('Color 2')) {
          btn.style.background = 'black';
          btn.style.color = '#00ff00';
          btn.style.borderColor = '#00ff00';
        }
      });

      const labels = menu.querySelectorAll('label, div');
      labels.forEach((label) => {
        if (!label.textContent.includes('✖')) {
          label.style.color = '#00ff00';
        }
      });

      blocks.forEach((b, i) => {
        b.color = colors[i % colors.length];
        b.w = blockSize;
        b.h = blockSize;
        b.displayW = blockSize;
        b.displayH = blockSize;
        b.rotation = 0;
        b.rotationSpeed = 0;
        b.vx = 0;
        b.vy = 0;
        b.angularVelocity = 0;
      });

      particles.splice(0, particles.length);
      effectParticles.splice(0, effectParticles.length);

      Object.keys(illusionsActive).forEach((k) => (illusionsActive[k] = false));

      physicsSettings.gravity = gravity;
      physicsSettings.friction = friction;
      physicsSettings.restitution = restitution;
      physicsSettings.airResistance = airResistance;
      physicsSettings.angularDamping = angularDamping;
      physicsSettings.wallBounce = wallBounce;
      physicsSettings.collisionEnergyLoss = 0.0;
      physicsSettings.magnetStrength = magnetStrength * 50;
      applyPhysicsSettings();
    }]
  ];

  funButtons.forEach(([n, f]) => {
    funTab.appendChild(createButton(n, f));
  });

  funTabHeader.addEventListener('click', () => {
    funTab.style.display = funTab.style.display === 'none' ? 'flex' : 'none';
    funTabHeader.innerText = funTab.style.display === 'none' ? 'Fun ▼' : 'Fun ▲';
  });

  // === Physics Settings Tab ===
  const physicsTabHeader = document.createElement('div');
  physicsTabHeader.innerText = 'Physics Settings ▼';
  physicsTabHeader.style.cursor = 'pointer';
  menu.appendChild(physicsTabHeader);

  const physicsTab = document.createElement('div');
  Object.assign(physicsTab.style, { display: 'none', flexDirection: 'column', gap: '5px' });
  menu.appendChild(physicsTab);

  physicsTabHeader.addEventListener('click', () => {
    physicsTab.style.display = physicsTab.style.display === 'none' ? 'flex' : 'none';
    physicsTabHeader.innerText =
      physicsTab.style.display === 'none' ? 'Physics Settings ▼' : 'Physics Settings ▲';
  });

  function addPhysicsSlider(label, key, min, max, step) {
    const { container, input, label: lbl } = createSlider(
      label,
      min,
      max,
      step,
      physicsSettings[key],
      (v) => {
        physicsSettings[key] = v;
        applyPhysicsSettings();
      }
    );
    input.oninput = (e) => {
      const val = parseFloat(e.target.value);
      physicsSettings[key] = val;
      lbl.innerText = `${label}: ${val.toFixed(2)}`;
      applyPhysicsSettings();
    };
    physicsTab.appendChild(container);
    return { input, lbl };
  }

  const gravCtrl = addPhysicsSlider('Gravity', 'gravity', 0, 3, 0.05);
  const airCtrl = addPhysicsSlider('Air Resistance', 'airResistance', 0.9, 1.0, 0.001);
  const angCtrl = addPhysicsSlider('Angular Damping', 'angularDamping', 0.9, 1.0, 0.005);
  const timeCtrl = addPhysicsSlider('Time Scale', 'timeScale', 0.1, 3, 0.1);
  const restCtrl = addPhysicsSlider('Restitution', 'restitution', 0, 1, 0.02);
  const fricCtrl = addPhysicsSlider('Collision Friction', 'friction', 0.5, 1, 0.01);
  const wallCtrl = addPhysicsSlider('Wall Bounce', 'wallBounce', 0, 1, 0.02);
  const colLossCtrl = addPhysicsSlider(
    'Collision Energy Loss',
    'collisionEnergyLoss',
    0,
    0.5,
    0.01
  );
  const angTransCtrl = addPhysicsSlider(
    'Angular Transfer',
    'angularVelocityTransfer',
    0,
    2,
    0.1
  );
  const magStrCtrl = addPhysicsSlider('Magnet Strength', 'magnetStrength', 0, 200, 5);

  const presetsLabel = document.createElement('div');
  presetsLabel.innerText = 'Presets:';
  presetsLabel.style.marginTop = '8px';
  presetsLabel.style.fontWeight = 'bold';
  physicsTab.appendChild(presetsLabel);

  function applyPreset(p) {
    Object.keys(p).forEach((k) => {
      if (k in physicsSettings) physicsSettings[k] = p[k];
    });
    applyPhysicsSettings();

    gravCtrl.input.value = physicsSettings.gravity;
    gravCtrl.lbl.innerText = `Gravity: ${physicsSettings.gravity.toFixed(2)}`;
    airCtrl.input.value = physicsSettings.airResistance;
    airCtrl.lbl.innerText = `Air Resistance: ${physicsSettings.airResistance.toFixed(3)}`;
    angCtrl.input.value = physicsSettings.angularDamping;
    angCtrl.lbl.innerText = `Angular Damping: ${physicsSettings.angularDamping.toFixed(3)}`;
    restCtrl.input.value = physicsSettings.restitution;
    restCtrl.lbl.innerText = `Restitution: ${physicsSettings.restitution.toFixed(2)}`;
    fricCtrl.input.value = physicsSettings.friction;
    fricCtrl.lbl.innerText = `Collision Friction: ${physicsSettings.friction.toFixed(2)}`;
    wallCtrl.input.value = physicsSettings.wallBounce;
    wallCtrl.lbl.innerText = `Wall Bounce: ${physicsSettings.wallBounce.toFixed(2)}`;
    colLossCtrl.input.value = physicsSettings.collisionEnergyLoss;
    colLossCtrl.lbl.innerText =
      `Collision Energy Loss: ${physicsSettings.collisionEnergyLoss.toFixed(2)}`;
    magStrCtrl.input.value = physicsSettings.magnetStrength;
    magStrCtrl.lbl.innerText =
      `Magnet Strength: ${physicsSettings.magnetStrength.toFixed(0)}`;
  }

  function addPresetButton(name, settings) {
    physicsTab.appendChild(createButton(name, () => applyPreset(settings)));
  }

  // Default-style preset: Normal Bounciness (no energy loss)
  addPresetButton('Normal Bounciness', {
    restitution: 1.0,
    wallBounce: 1.0,
    collisionEnergyLoss: 0.0
  });

  addPresetButton('Space', {
    gravity: 0,
    airResistance: 1,
    restitution: 0.95,
    collisionEnergyLoss: 0.05
  });

  addPresetButton('Water', {
    gravity: 0.2,
    airResistance: 0.95,
    restitution: 0.3,
    collisionEnergyLoss: 0.2
  });

  addPresetButton('Bouncy', {
    restitution: 0.95,
    friction: 0.98,
    wallBounce: 0.95,
    collisionEnergyLoss: 0.05
  });

  addPresetButton('Sticky', {
    restitution: 0.1,
    friction: 0.5,
    wallBounce: 0.3,
    collisionEnergyLoss: 0.4
  });

  addPresetButton('Realistic', {
    gravity: 0.6,
    airResistance: 0.999,
    restitution: 0.8,
    friction: 0.85,
    wallBounce: 0.75,
    collisionEnergyLoss: 0.15
  });

  physicsTab.appendChild(
    createButton('Reset Physics', () => {
      physicsSettings = {
        gravity: defaultSettings.gravity,
        airResistance: 0.999,
        angularDamping: 0.98,
        restitution: defaultSettings.restitution,
        friction: defaultSettings.friction,
        wallBounce: defaultSettings.wallBounce,
        magnetStrength: defaultSettings.magnetStrength * 50,
        collisionEnergyLoss: 0.15,
        angularVelocityTransfer: 0.5,
        particleEmissionRate: 5,
        particleLife: 100,
        particleSize: 3,
        explosionParticles: 20,
        trailLength: 10,
        shadowBlur: 15,
        shadowOpacity: 0.5,
        trailOpacity: 0.3,
        glowIntensity: 1.0,
        timeScale: 1.0
      };
      applyPhysicsSettings();

      gravCtrl.input.value = physicsSettings.gravity;
      gravCtrl.lbl.innerText = `Gravity: ${physicsSettings.gravity.toFixed(2)}`;
      airCtrl.input.value = physicsSettings.airResistance;
      airCtrl.lbl.innerText = `Air Resistance: ${physicsSettings.airResistance.toFixed(3)}`;
      angCtrl.input.value = physicsSettings.angularDamping;
      angCtrl.lbl.innerText = `Angular Damping: ${physicsSettings.angularDamping.toFixed(3)}`;
      restCtrl.input.value = physicsSettings.restitution;
      restCtrl.lbl.innerText = `Restitution: ${physicsSettings.restitution.toFixed(2)}`;
      fricCtrl.input.value = physicsSettings.friction;
      fricCtrl.lbl.innerText = `Collision Friction: ${physicsSettings.friction.toFixed(2)}`;
      wallCtrl.input.value = physicsSettings.wallBounce;
      wallCtrl.lbl.innerText = `Wall Bounce: ${physicsSettings.wallBounce.toFixed(2)}`;
      colLossCtrl.input.value = physicsSettings.collisionEnergyLoss;
      colLossCtrl.lbl.innerText =
        `Collision Energy Loss: ${physicsSettings.collisionEnergyLoss.toFixed(2)}`;
      magStrCtrl.input.value = physicsSettings.magnetStrength;
      magStrCtrl.lbl.innerText =
        `Magnet Strength: ${physicsSettings.magnetStrength.toFixed(0)}`;
    })
  );

  // === Illusions Tab ===
  const illusionsTabHeader = document.createElement('div');
  illusionsTabHeader.innerText = 'Illusions ▼';
  illusionsTabHeader.style.cursor = 'pointer';
  menu.appendChild(illusionsTabHeader);

  const illusionsTab = document.createElement('div');
  Object.assign(illusionsTab.style, { display: 'none', flexDirection: 'column', gap: '5px' });
  menu.appendChild(illusionsTab);

  function toggleIllusionExclusive(name) {
    const wasOn = illusionsActive[name];
    Object.keys(illusionsActive).forEach((k) => (illusionsActive[k] = false));
    illusionsActive[name] = !wasOn;
  }

  const illusionsButtons = [
    ['Spiral (BW)', () => toggleIllusionExclusive('spiral')],
    ['Breathing Grid', () => toggleIllusionExclusive('breathingGrid')],
    ['Wave Tunnel', () => toggleIllusionExclusive('waveTunnel')],
    ['Vortex Swirl', () => toggleIllusionExclusive('vortex')],
    ['Orbit Rings', () => toggleIllusionExclusive('orbitRing')],
    ['Checker Spin', () => toggleIllusionExclusive('checkerSpin')],
    ['Flip Strip', () => toggleIllusionExclusive('flipStrip')],
    ['Zoom Pulse', () => toggleIllusionExclusive('zoomPulse')],
    ['Swirl Field (Cursor)', () => toggleIllusionExclusive('swirlField')],
    ['Hypno Hue (Color Only)', () => {
      illusionsActive.hypnoHue = !illusionsActive.hypnoHue;
    }],
    ['Clear Illusions', () => {
      Object.keys(illusionsActive).forEach((k) => (illusionsActive[k] = false));
    }]
  ];

  illusionsButtons.forEach(([n, f]) => {
    illusionsTab.appendChild(createButton(n, f));
  });

  illusionsTabHeader.addEventListener('click', () => {
    illusionsTab.style.display = illusionsTab.style.display === 'none' ? 'flex' : 'none';
    illusionsTabHeader.innerText =
      illusionsTab.style.display === 'none' ? 'Illusions ▼' : 'Illusions ▲';
  });

  // === Toggle menu with key ===
  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'e') {
      menu.style.display = menu.style.display === 'none' ? 'flex' : 'none';
    }
  });

  // === Helpers ===
  function ensureBlocks(count) {
    while (blocks.length < count) {
      blocks.push(makeBlock(Math.random() * canvas.width, Math.random() * canvas.height));
    }
  }

  let draggingBlock = null;
  function getPos(e) {
    if (e.touches && e.touches.length) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
  }

  function startDrag(e) {
    const { x, y } = getPos(e);
    prevMouseX = x;
    prevMouseY = y;
    for (const b of blocks) {
      if (x > b.x && x < b.x + b.w && y > b.y && y < b.y + b.h) {
        b.isDragging = true;
        draggingBlock = b;
        return;
      }
    }
    for (const d of dynamites) {
      if (x > d.x && x < d.x + d.w && y > d.y && y < d.y + d.h) {
        d.isDragging = true;
        return;
      }
    }
  }

  function moveDrag(e) {
    const { x, y } = getPos(e);
    if (draggingBlock) {
      draggingBlock.x += x - prevMouseX;
      draggingBlock.y += y - prevMouseY;
      draggingBlock.vx = (x - prevMouseX) * 0.8;
      draggingBlock.vy = (y - prevMouseY) * 0.8;
      draggingBlock.angularVelocity = (x - prevMouseX) * 0.01;
    }
    prevMouseX = x;
    prevMouseY = y;
  }

  function endDrag() {
    if (draggingBlock) draggingBlock.isDragging = false;
    draggingBlock = null;
    dynamites.forEach((d) => (d.isDragging = false));
  }

  canvas.addEventListener('mousemove', (e) => {
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  canvas.addEventListener('mousedown', startDrag);
  canvas.addEventListener('mousemove', moveDrag);
  canvas.addEventListener('mouseup', endDrag);
  canvas.addEventListener('touchstart', startDrag);
  canvas.addEventListener('touchmove', moveDrag);
  canvas.addEventListener('touchend', endDrag);

  window.addEventListener('resize', () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
  });

  // === OPTIMIZATION: Improved Collision Detection with Spatial Grid ===
  function handleCollisions() {
    // Skip collision checks on some frames for performance
    if (frameCount % performanceSettings.collisionCheckInterval !== 0) return 0;
   
    const newCollisions = new Set();
    let hasRolling = false;
    let collisionCount = 0;

    // Clear and repopulate spatial grid
    spatialGrid.clear();
    blocks.forEach(block => spatialGrid.addObject(block));

    blocks.forEach((block, i) => {
      const nearby = spatialGrid.getNearbyObjects(block);
     
      nearby.forEach(other => {
        const j = blocks.indexOf(other);
        if (i >= j) return; // Skip self and already checked pairs
       
        if (
          block.x < other.x + other.w &&
          block.x + block.w > other.x &&
          block.y < other.y + other.h &&
          block.y + block.h > other.y
        ) {
          const overlapX = Math.min(block.x + block.w - other.x, other.x + other.w - block.x);
          const overlapY = Math.min(block.y + block.h - other.y, other.y + other.h - block.y);
          const id = `${i}-${j}`;
          newCollisions.add(id);

          const relV = Math.sqrt((block.vx - other.vx) ** 2 + (block.vy - other.vy) ** 2);
          if (overlapY > overlapX && relV > 0.5 && relV < 3) hasRolling = true;

          if (!activeCollisions.has(id) && soundCooldowns.collision <= 0) {
            playSound('collision');
            soundCooldowns.collision = SOUND_COOLDOWN_TIME;
          }

          // FIXED: Proper collision response
          if (overlapX < overlapY) {
            // Separate blocks horizontally
            const sx = overlapX * 0.5;
            if (block.x < other.x) {
              block.x -= sx;
              other.x += sx;
            } else {
              block.x += sx;
              other.x -= sx;
            }
           
            // Calculate proper impulse for horizontal collision
            const dvx = block.vx - other.vx;
            const totalMass = block.mass + other.mass;
            const impulse = ((1 + restitution) * dvx) / totalMass;
           
            // Apply impulse based on mass ratio
            block.vx -= impulse * other.mass;
            other.vx += impulse * block.mass;
           
            // Add some rotation from collision
            block.rotationSpeed += (Math.random() - 0.5) * 0.05;
            other.rotationSpeed += (Math.random() - 0.5) * 0.05;
          } else {
            // Separate blocks vertically
            const sy = overlapY * 0.5;
            if (block.y < other.y) {
              block.y -= sy;
              other.y += sy;
            } else {
              block.y += sy;
              other.y -= sy;
            }
           
            // Calculate proper impulse for vertical collision
            const dvy = block.vy - other.vy;
            const totalMass = block.mass + other.mass;
            const impulse = ((1 + restitution) * dvy) / totalMass;
           
            // Apply impulse based on mass ratio
            block.vy -= impulse * other.mass;
            other.vy += impulse * block.mass;
           
            // Add some rotation from collision
            block.rotationSpeed += (Math.random() - 0.5) * 0.05;
            other.rotationSpeed += (Math.random() - 0.5) * 0.05;
          }
          collisionCount++;
        }
      });
    });

    if (hasRolling && soundCooldowns.rolling <= 0) {
      playSound('rolling');
      soundCooldowns.rolling = 200;
    }

    activeCollisions.clear();
    newCollisions.forEach((id) => activeCollisions.add(id));
   
    return collisionCount;
  }

  function applyMagnetize() {
    const mx = lastMouseX;
    const my = lastMouseY;
    blocks.forEach((b) => {
      const dx = mx - (b.x + b.w / 2);
      const dy = my - (b.y + b.h / 2);
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const dir = magnetInvert ? -1 : 1;
     
      // FIXED: Better magnet strength calculation with falloff
      const maxForce = magnetStrength * 50;
      const force = Math.min(maxForce, maxForce / (dist * 0.01));
     
      // Apply force with velocity damping to prevent overshooting
      const forceX = (dx / dist) * force * dir * 0.1;
      const forceY = (dy / dist) * force * dir * 0.1;
     
      b.vx += forceX;
      b.vy += forceY;
     
      // Add slight rotation toward mouse
      const angleToMouse = Math.atan2(dy, dx);
      b.rotationSpeed += (angleToMouse - b.rotation) * 0.01;
    });
  }

  function applyCenterPull() {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    blocks.forEach((b) => {
      const dx = cx - (b.x + b.w / 2);
      const dy = cy - (b.y + b.h / 2);
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
     
      // FIXED: Better center pull with gentle force and falloff
      const maxForce = 80;
      const force = Math.min(maxForce, maxForce / (dist * 0.02));
     
      // Apply gentle pulling force
      b.vx += (dx / dist) * force * 0.05;
      b.vy += (dy / dist) * force * 0.05;
     
      // Add orbital rotation for visual effect
      const angleToCenter = Math.atan2(dy, dx);
      b.rotationSpeed += Math.sin(angleToCenter) * 0.02;
    });
  }

  // === Illusion layouts ===
  function applyIllusions(t) {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    if (illusionsActive.spiral) {
      ensureBlocks(80);
      const turns = 3;
      const speed = 0.8;
      blocks.forEach((b, i) => {
        const a = (i / blocks.length) * turns * Math.PI * 2 + t * speed;
        const r = (i / blocks.length) * Math.min(cx, cy) * 0.95;
        const x = cx + Math.cos(a) * r;
        const y = cy + Math.sin(a) * r;
        b.x = x - 15;
        b.y = y - 15;
        b.displayW = b.displayH = 30;
        b.w = b.h = 30;
        b.color = (i + Math.floor(t * 4 + r / 40)) % 2 === 0 ? '#000' : '#fff';
        b.shape = 'rectangle';
        b.rotation = a + Math.PI / 2;
      });
    }

    if (illusionsActive.breathingGrid) {
      ensureBlocks(80);
      const cols = 10;
      const rows = 8;
      const amp = 0.4;
      const scale = 1 + Math.sin(t * 2) * amp;
      const cellW = (canvas.width * 0.8) / cols;
      const cellH = (canvas.height * 0.8) / rows;
      let idx = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++, idx++) {
          const b = blocks[idx];
          const baseX = canvas.width * 0.1 + c * cellW;
          const baseY = canvas.height * 0.1 + r * cellH;
          b.displayW = b.displayH = Math.min(cellW, cellH) * 0.6 * scale;
          b.w = b.h = b.displayW;
          b.x = baseX + cellW / 2 - b.displayW / 2;
          b.y = baseY + cellH / 2 - b.displayH / 2;
          b.color = (c + r) % 2 === 0 ? '#fff' : '#000';
          b.shape = 'rectangle';
          b.rotation = 0;
        }
      }
    }

    if (illusionsActive.waveTunnel) {
      ensureBlocks(80);
      const layers = 6;
      blocks.forEach((b, i) => {
        const ring = i % layers;
        const ang = (i / blocks.length) * Math.PI * 2 * layers;
        const baseR =
          ((ring + 1) / (layers + 1)) * Math.min(cx, cy) * 0.95;
        const r = baseR + Math.sin(t * 3 + ring) * 15;
        const x = cx + Math.cos(ang) * r;
        const y = cy + Math.sin(ang) * r;
        b.x = x - 10;
        b.y = y - 10;
        b.displayW = b.displayH = 20 + ring * 2;
        b.w = b.h = b.displayW;
        b.color = (ring + Math.floor(t * 6)) % 2 === 0 ? '#fff' : '#000';
        b.shape = 'circle';
        b.rotation = 0;
      });
    }

    if (illusionsActive.vortex) {
      ensureBlocks(80);
      blocks.forEach((b, i) => {
        const a = (i / blocks.length) * Math.PI * 4 + t * 2;
        const r = (i / blocks.length) * Math.min(cx, cy);
        const x = cx + Math.cos(a) * r;
        const y = cy + Math.sin(a) * r;
        b.x = x - 8;
        b.y = y - 8;
        b.displayW = b.displayH = 16;
        b.w = b.h = 16;
        b.color = i % 2 === 0 ? '#fff' : '#000';
        b.shape = 'triangle';
        b.rotation = a + Math.PI / 2;
      });
    }

    if (illusionsActive.orbitRing) {
      ensureBlocks(80);
      const rings = 4;
      const per = Math.floor(blocks.length / rings);
      for (let r = 0; r < rings; r++) {
        const radius =
          ((r + 1) / (rings + 1)) * Math.min(cx, cy) * 0.9;
        for (let j = 0; j < per; j++) {
          const idx = r * per + j;
          const b = blocks[idx];
          const a =
            (j / per) * Math.PI * 2 + t * (r % 2 === 0 ? 0.8 : -0.8);
          const x = cx + Math.cos(a) * radius;
          const y = cy + Math.sin(a) * radius;
          b.x = x - 6;
          b.y = y - 6;
          b.displayW = b.displayH = 12;
          b.w = b.h = 12;
          b.color = j % 2 === 0 ? '#fff' : '#000';
          b.shape = 'circle';
          b.rotation = 0;
        }
      }
    }

    if (illusionsActive.checkerSpin) {
      ensureBlocks(64);
      const n = 8;
      const size = Math.min(canvas.width, canvas.height) * 0.6;
      const cell = size / n;
      const angle = t * 1.2;
      for (let i = 0; i < n * n; i++) {
        const b = blocks[i];
        const row = Math.floor(i / n);
        const col = i % n;
        const lx = (col + 0.5) * cell - size / 2;
        const ly = (row + 0.5) * cell - size / 2;
        const rx =
          lx * Math.cos(angle) - ly * Math.sin(angle);
        const ry =
          lx * Math.sin(angle) + ly * Math.cos(angle);
        b.displayW = b.displayH = cell * 0.9;
        b.w = b.h = b.displayW;
        b.x = cx + rx - b.displayW / 2;
        b.y = cy + ry - b.displayH / 2;
        b.color = (row + col) % 2 === 0 ? '#fff' : '#000';
        b.shape = 'rectangle';
        b.rotation = 0;
      }
    }

    if (illusionsActive.flipStrip) {
      ensureBlocks(40);
      const yCenter = cy;
      blocks.forEach((b, i) => {
        const phase = (i / blocks.length) * Math.PI * 4;
        const offset = Math.sin(t * 4 + phase) * 40;
        b.displayW = 30;
        b.displayH = 30;
        b.w = b.h = 30;
        b.x = (i / blocks.length) * canvas.width;
        b.y =
          yCenter -
          b.displayH / 2 +
          offset * (i % 2 === 0 ? 1 : -1);
        b.color = i % 2 === 0 ? '#fff' : '#000';
        b.shape = 'rectangle';
        b.rotation = 0;
      });
    }

    if (illusionsActive.zoomPulse) {
      ensureBlocks(60);
      const layers = 5;
      const per = Math.floor(blocks.length / layers);
      for (let r = 0; r < layers; r++) {
        const base =
          ((r + 1) / (layers + 1)) * Math.min(cx, cy);
        const pulse = 1 + Math.sin(t * 3 + r) * 0.2;
        const radius = base * pulse;
        for (let j = 0; j < per; j++) {
          const idx = r * per + j;
          const b = blocks[idx];
          const a = (j / per) * Math.PI * 2;
          b.x = cx + Math.cos(a) * radius - 6;
          b.y = cy + Math.sin(a) * radius - 6;
          b.displayW = b.displayH = 12;
          b.w = b.h = 12;
          b.color = j % 2 === 0 ? '#fff' : '#000';
          b.shape = 'circle';
          b.rotation = 0;
        }
      }
    }

    if (illusionsActive.swirlField) {
      ensureBlocks(80);
      const R = 200;
      blocks.forEach((b, i) => {
        const dx = b.x + b.w / 2 - mouseX;
        const dy = b.y + b.h / 2 - mouseY;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const factor = Math.max(0, 1 - dist / R);
        const angle = t * 5 * factor;
        const sx = Math.cos(angle) * dx - Math.sin(angle) * dy;
        const sy = Math.sin(angle) * dx + Math.cos(angle) * dy;
        const x = mouseX + sx;
        const y = mouseY + sy;
        b.displayW = b.displayH = 10 + factor * 15;
        b.w = b.h = b.displayW;
        b.x = x - b.displayW / 2;
        b.y = y - b.displayH / 2;
        b.color = factor > 0.5 ? '#fff' : '#000';
        b.shape = i % 2 === 0 ? 'circle' : 'rectangle';
        b.rotation = 0;
      });
    }

    if (illusionsActive.hypnoHue) {
      const hueBase = (t * 80) % 360;
      blocks.forEach((b, i) => {
        const f = i / Math.max(1, blocks.length);
        const hue = (hueBase + f * 180) % 360;
        b.color = `hsl(${hue},100%,60%)`;
      });
    }
  }

  // === Dynamite explosion ===
  function explode(d) {
    d.exploded = true;
    playSound('explosion');

    const blastRadius = 250;
    const blastPower = 50;

    blocks.forEach((b) => {
      const dx = b.x + b.w / 2 - (d.x + d.w / 2);
      const dy = b.y + b.h / 2 - (d.y + d.h / 2);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < blastRadius && dist > 0) {
        const force = (1 - dist / blastRadius) * blastPower;
        b.vx += (dx / dist) * force;
        b.vy += (dy / dist) * force - 8;
        b.angularVelocity = (Math.random() - 0.5) * 0.4;
      }
    });

    for (let i = 0; i < 30; i++) {
      const particle = makeParticle(d.x + d.w / 2, d.y + d.h / 2, d.color);
      particles.push(particle);
    }

    const start = performance.now();
    const tick = () => {
      if (performance.now() - start < 500) {
        requestAnimationFrame(tick);
      } else {
        const idx = dynamites.indexOf(d);
        if (idx !== -1) dynamites.splice(idx, 1);
      }
    };
    tick();
  }

  // === OPTIMIZATION: Improved Update Loop ===
  function update() {
    frameCount++;
   
    // OPTIMIZATION: Skip color pulse updates on some frames
    if (frameCount % 2 === 0 && colorPulseMode) {
      pulsePhase += pulseSpeed;
      if (pulsePhase > 1) pulsePhase = 0;
    }

    // Sound cooldowns
    for (const k in soundCooldowns) {
      if (soundCooldowns[k] > 0) soundCooldowns[k] -= 16.67;
    }

    // OPTIMIZATION: Skip particle updates on some frames
    if (frameCount % performanceSettings.particleUpdateInterval === 0) {
      updateEffectParticles();
    }

    const t = performance.now() / 1000;

    if (gravityWave) {
      gravity = 0.6 + Math.sin(t * 2) * 0.4;
    }
    if (gravitySpin) {
      gravityDir = Math.sin(t) >= 0 ? 1 : -1;
    }

    // OPTIMIZATION: Skip physics updates for off-screen blocks and limit processed blocks
    const screenBounds = {
      left: -100,
      right: canvas.width + 100,
      top: -100,
      bottom: canvas.height + 100
    };

    // Process all blocks
    const blocksToProcess = blocks;

    blocksToProcess.forEach((b) => {
      // Skip off-screen blocks
      if (b.x + b.w < screenBounds.left || b.x > screenBounds.right ||
          b.y + b.h < screenBounds.top || b.y > screenBounds.bottom) {
        return;
      }
     
      // OPTIMIZATION: Simplified trail updates
      if (b.vx !== 0 || b.vy !== 0) {
        b.trail.push({ x: b.x + b.w / 2, y: b.y + b.h / 2, age: 0 });
        if (b.trail.length > b.maxTrailLength) b.trail.shift();
      }
      if (frameCount % 4 === 0) { // Update trail age less frequently
        b.trail.forEach((p) => p.age++);
      }

      // Shrink / grow target
      if (shrinkMode || growMode) {
        b.displayW += (targetSize.width - b.displayW) * 0.1;
        b.displayH += (targetSize.height - b.displayH) * 0.1;
        b.w = b.displayW;
        b.h = b.displayH;
      }

      if (!b.isDragging) {
        // Gravity
        if (antiGravityMode) {
          b.vy -= gravity * 0.5 * slowMo;
        } else if (verticalMovement) {
          b.vy += gravity * gravityDir * slowMo;
        }

        // Air resistance
        b.vx *= airResistance;
        b.vy *= airResistance;

        if (!horizontalMovement) b.vx = 0;

        // FIXED: Proper tornado effect
        if (tornadoMode) {
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          const dx = b.x + b.w / 2 - cx;
          const dy = b.y + b.h / 2 - cy;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
         
          // Calculate tangential force for spiral motion
          const angle = Math.atan2(dy, dx);
          const tangentX = -Math.sin(angle);
          const tangentY = Math.cos(angle);
         
          // Stronger spiral force with distance falloff
          const spiralStrength = 150 / Math.max(1, dist * 0.01);
          const pullStrength = 50 / Math.max(1, dist * 0.01);
         
          // Apply spiral motion and inward pull
          b.vx += tangentX * spiralStrength * 0.1 - (dx / dist) * pullStrength * 0.05;
          b.vy += tangentY * spiralStrength * 0.1 - (dy / dist) * pullStrength * 0.05;
         
          // Add spinning motion
          b.rotationSpeed += 0.1;
        }

        // Integrate
        b.x += b.vx * slowMo;
        b.y += b.vy * slowMo;

        // Rotation (OPTIMIZATION: Simplified)
        if (rotateMode) {
          b.rotation += (b.rotationSpeed || 0.05);
          b.rotationSpeed *= 0.99; // Simplified damping
        }

        // Size wave
        if (sizeWaveMode) {
          const wave = Math.sin(performance.now() / 500 + b.x / 100);
          b.w = blockSize + wave * 30;
          b.h = blockSize + wave * 30;
          b.displayW = b.w;
          b.displayH = b.h;
        }

        // Wall collisions (use collisionEnergyLoss)
        let bounced = false;
        const energyLoss = 1 - (physicsSettings.collisionEnergyLoss || 0);

        // Bottom
        if (b.y + b.h > canvas.height) {
          b.y = canvas.height - b.h;
          b.vy *= -wallBounce * energyLoss;
          b.vx *= friction;
          bounced = true;
        } else if (b.y < 0) {
          // Top
          b.y = 0;
          b.vy *= -wallBounce * energyLoss;
          b.vx *= friction;
          bounced = true;
        }

        // Right
        if (b.x + b.w > canvas.width) {
          b.x = canvas.width - b.w;
          b.vx *= -wallBounce * energyLoss;
          b.vy *= friction;
          bounced = true;
        } else if (b.x < 0) {
          // Left
          b.x = 0;
          b.vx *= -wallBounce * energyLoss;
          b.vy *= friction;
          bounced = true;
        }

        if (bounced && soundCooldowns.bounce <= 0) {
          const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
          if (speed > 2) {
            playSound('bounce');
            soundCooldowns.bounce = SOUND_COOLDOWN_TIME;
          }
        }
      }

      // OPTIMIZATION: Skip color updates on some frames
      if (frameCount % 3 === 0) {
        // Color modes
        if (colorPulseMode) {
          const f = (Math.sin(pulsePhase * Math.PI * 2) + 1) / 2;
          b.color = interpolateColor(pulseColor1, pulseColor2, f);
        } else if (rainbowMode) {
          b.color = `hsl(${(performance.now() / 10 + b.x) % 360},100%,60%)`;
        } else if (randomFrameColors) {
          b.color = randomColor();
        }
      }
    });

    // Illusions override layout/colors as needed
    applyIllusions(t);

    // Dynamites (OPTIMIZATION: Simplified)
    dynamites.forEach((d) => {
      if (d.exploded) return;
      if (!d.isDragging) {
        d.vy += gravity;
        d.vx *= airResistance;
        d.vy *= airResistance;
        d.x += d.vx;
        d.y += d.vy;
        if (d.y + d.h > canvas.height) {
          d.y = canvas.height - d.h;
          d.vy *= -0.3;
          d.vx *= 0.8;
        }
      }
      d.timer--;
      if (d.timer <= 0 && !d.exploded) explode(d);
    });

    // OPTIMIZATION: Particle cleanup and pooling
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.vy += p.gravity || 0.2;
      p.vx *= p.airResistance || 0.99;
      p.vy *= p.airResistance || 0.99;
      p.x += p.vx;
      p.y += p.vy;
      p.life--;
      if (p.life <= 0) {
        // Return to pool
        if (particlePool.length < 100) {
          particlePool.push(p);
        }
        particles.splice(i, 1);
      }
    }

    if (magnetize) applyMagnetize();
    if (centerPull) applyCenterPull();
    if (collisionsEnabled) handleCollisions();
  }

  // === OPTIMIZATION: Improved Draw Loop ===
  function draw() {
    // Skip rendering on some frames for performance
    if (frameCount % performanceSettings.renderInterval !== 0) return;
   
    if (!trailMode) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = 'rgba(0,0,0,0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Draw all particles
    const visibleParticles = particles.filter(p =>
      p.x > -50 && p.x < canvas.width + 50 &&
      p.y > -50 && p.y < canvas.height + 50
    );
   
    // OPTIMIZATION: Simplified trail rendering
    if (trailMode) {
      ctx.lineWidth = 2;
      blocks.forEach((b) => {
        if (b.trail.length > 1) {
          ctx.strokeStyle = b.color;
          ctx.beginPath();
          const trailStep = Math.max(1, Math.floor(b.trail.length / 10)); // Draw every Nth trail point
          for (let i = 0; i < b.trail.length; i += trailStep) {
            const pt = b.trail[i];
            const alpha = (1 - pt.age / b.maxTrailLength) * 0.5;
            ctx.globalAlpha = alpha;
            if (i === 0) {
              ctx.moveTo(pt.x, pt.y);
            } else {
              ctx.lineTo(pt.x, pt.y);
            }
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      });
    }

    // Draw all effect particles
    effectParticles.forEach((p) => {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life / (p.maxLife || 100);
      if (p.type === 'sparkle' && p.twinkle) {
        ctx.globalAlpha *= Math.abs(Math.sin(p.twinkle));
      }
      if (p.type === 'electric' && p.intensity) {
        ctx.globalAlpha *= 0.3 + p.intensity * 0.7;
      }
      if (p.type === 'plasma' && p.energy) {
        ctx.globalAlpha *=
          0.5 + Math.sin(performance.now() / 100 + p.energy * 10) * 0.5;
      }
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.globalAlpha = 1;

    // OPTIMIZATION: Simplified particle rendering
    visibleParticles.forEach((p) => {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life / 100;
      // OPTIMIZATION: Use fillRect instead of arc for better performance
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    });

    ctx.globalAlpha = 1;

    // Draw all visible blocks
    const visibleBlocks = blocks.filter(b =>
      b.x + b.w > -50 && b.x < canvas.width + 50 &&
      b.y + b.h > -50 && b.y < canvas.height + 50
    );

    // OPTIMIZATION: Batch render blocks by type to reduce state changes
    const rectangles = visibleBlocks.filter(b => b.shape === 'rectangle');
    const circles = visibleBlocks.filter(b => b.shape === 'circle');
    const triangles = visibleBlocks.filter(b => b.shape === 'triangle');

    // Render rectangles
    rectangles.forEach((b) => {
      ctx.fillStyle = flashMode ? randomColor() : b.color;
      // OPTIMIZATION: Skip shadows for better performance
      ctx.fillRect(b.x, b.y, b.displayW, b.displayH);
    });

    // Render circles
    circles.forEach((b) => {
      ctx.fillStyle = flashMode ? randomColor() : b.color;
      ctx.beginPath();
      ctx.arc(
        b.x + b.displayW / 2,
        b.y + b.displayH / 2,
        b.displayW / 2,
        0,
        Math.PI * 2
      );
      ctx.fill();
    });

    // Render triangles
    triangles.forEach((b) => {
      ctx.fillStyle = flashMode ? randomColor() : b.color;
      ctx.beginPath();
      ctx.moveTo(b.x + b.displayW / 2, b.y);
      ctx.lineTo(b.x, b.y + b.displayH);
      ctx.lineTo(b.x + b.displayW, b.y + b.displayH);
      ctx.closePath();
      ctx.fill();
    });

    // OPTIMIZATION: Simplified dynamite rendering
    dynamites.forEach((d) => {
      if (d.exploded) return;

      ctx.fillStyle = '#8B4513';
      ctx.fillRect(d.x + 5, d.y + 10, d.w - 10, d.h - 20);

      ctx.fillStyle = d.color;
      ctx.fillRect(d.x, d.y, d.w, d.h - 20);

      // OPTIMIZATION: Simplified fuse rendering
      if (d.timer < 60) {
        ctx.fillStyle = '#FFFF00';
        ctx.fillRect(d.x + d.w / 2 - 2, d.y - 10, 4, 10);
      }

      ctx.fillStyle = d.timer < 60 ? '#ffff00' : '#000000';
      ctx.font = 'bold 12px Arial';
      ctx.fillText(
        Math.ceil(d.timer / 60),
        d.x + d.w / 2 - 5,
        d.y + d.h / 2 + 5
      );
    });
  }

  // === OPTIMIZATION: Performance Monitor ===
  let lastPerfUpdate = performance.now();
  let fps = 60;
 
  function updatePerformanceMonitor() {
    const now = performance.now();
   
    if (now - lastPerfUpdate >= 1000) {
      fps = Math.round(1000 / (now - lastPerfUpdate) * frameCount);
      frameCount = 0;
      lastPerfUpdate = now;
     
      // Log performance warnings
      if (fps < 30 && blocks.length > 50) {
        console.warn(`⚠️ Low FPS: ${fps} with ${blocks.length} shapes. Consider reducing shape count.`);
      }
     
      if (fps < 20) {
        // Auto-adjust performance settings
        performanceSettings.collisionCheckInterval = Math.min(4, performanceSettings.collisionCheckInterval + 1);
        performanceSettings.particleUpdateInterval = Math.min(3, performanceSettings.particleUpdateInterval + 1);
        performanceSettings.renderInterval = Math.min(2, performanceSettings.renderInterval + 1);
        console.log(`🔧 Auto-adjusting performance settings. FPS: ${fps}`);
      } else if (fps > 55) {
        // Restore full performance
        performanceSettings.collisionCheckInterval = 2;
        performanceSettings.particleUpdateInterval = 2;
        performanceSettings.renderInterval = 1;
      }
    }
  }

  // === Animation loop ===
  function animate() {
    update();
    draw();
    updatePerformanceMonitor();
    requestAnimationFrame(animate);
  }

  // Initialize audio context on first interaction
  document.addEventListener('click', () => {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }, { once: true });

  animate();
})(); // end IIFE

// --- Autoclicker setup ---
let autoclickerRunning = false;
let clickInterval;

let mouseX = 0;
let mouseY = 0;

window.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

function clickUnderCursor() {
  const el = document.elementFromPoint(mouseX, mouseY);
  if (!el) return;

  const evt = new MouseEvent('click', {
    view: window,
    bubbles: true,
    cancelable: true,
    clientX: mouseX,
    clientY: mouseY,
    button: 0
  });

  el.dispatchEvent(evt);
}

function startAutoclicker() {
  clickInterval = setInterval(clickUnderCursor, 1);
  console.log("Autoclicker started! Press ']' to stop.");
}

function stopAutoclicker() {
  clearInterval(clickInterval);
  console.log('Autoclicker stopped!');
}

document.addEventListener('keydown', (e) => {
  if (e.key === ']') {
    if (autoclickerRunning) {
      stopAutoclicker();
    } else {
      startAutoclicker();
    }
    autoclickerRunning = !autoclickerRunning;
  }
});

console.log(
  "Autoclicker ready! Hover over an element and press ']' to start/stop left-clicking."
);