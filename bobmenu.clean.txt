(() => {
    // === Enhanced Audio System ===
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    
    function playSound(type) {
        try {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            switch (type) {
                case 'bounce':
                    oscillator.frequency.value = 200 + Math.random() * 50;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'collision':
                    oscillator.frequency.value = 150 + Math.random() * 30;
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'explosion':
                    oscillator.frequency.value = 50 + Math.random() * 20;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'click':
                    oscillator.frequency.value = 800 + Math.random() * 100;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.05);
                    break;
                case 'whoosh':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(
                        100 + Math.random() * 50,
                        audioCtx.currentTime + 0.3
                    );
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'rolling':
                    oscillator.frequency.value = 60 + Math.random() * 20;
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
            }
        } catch (e) {
            // Audio might be blocked, but that's okay
        }
    }
    
    // === Setup canvas ===
    const canvas = document.createElement('canvas');
    Object.assign(canvas.style, {
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        zIndex: 1,
        touchAction: 'none'
    });
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    
    // === OPTIMIZATION: Spatial Grid for Collision Detection ===
    class SpatialGrid {
        constructor(cellSize) {
            this.cellSize = cellSize;
            this.cells = new Map();
        }
        
        clear() {
            this.cells.clear();
        }
        
        getKey(x, y) {
            const cellX = Math.floor(x / this.cellSize);
            const cellY = Math.floor(y / this.cellSize);
            return `${cellX},${cellY}`;
        }
        
        addObject(obj) {
            const keys = this.getKeysForObject(obj);
            keys.forEach(key => {
                if (!this.cells.has(key)) {
                    this.cells.set(key, []);
                }
                this.cells.get(key).push(obj);
            });
        }
        
        getKeysForObject(obj) {
            const keys = new Set();
            const startX = Math.floor(obj.x / this.cellSize);
            const startY = Math.floor(obj.y / this.cellSize);
            const endX = Math.floor((obj.x + obj.w) / this.cellSize);
            const endY = Math.floor((obj.y + obj.h) / this.cellSize);
            
            for (let x = startX; x <= endX; x++) {
                for (let y = startY; y <= endY; y++) {
                    keys.add(`${x},${y}`);
                }
            }
            return Array.from(keys);
        }
        
        getNearbyObjects(obj) {
            const keys = this.getKeysForObject(obj);
            const nearby = new Set();
            keys.forEach(key => {
                const objects = this.cells.get(key);
                if (objects) {
                    objects.forEach(o => {
                        if (o !== obj) nearby.add(o);
                    });
                }
            });
            return Array.from(nearby);
        }
    }
    
    // === Physics constants (base) ===
    let gravity = 0.6;
    let gravityDir = 1;
    let friction = 0.85;
    let wallBounce = 0.75;
    let restitution = 0.8;
    let collisionsEnabled = true;
    let blockSize = 100;
    let airResistance = 0.999;
    let angularDamping = 0.98;
    let magnetStrength = 3;
    
    // === OPTIMIZATION: Performance settings ===
    const performanceSettings = {
        maxShapes: 999999, // No limits
        maxParticles: 999999, // No limits
        spatialGridSize: 150, // Larger grid cells = fewer checks
        collisionCheckInterval: 2, // Check collisions every N frames
        particleUpdateInterval: 2, // Update particles every N frames
        renderInterval: 1 // Render every N frames
    };
    
    // === Unified Physics Settings (for UI + presets) ===
    let physicsSettings = {
        gravity,
        airResistance,
        angularDamping,
        restitution,
        friction,
        wallBounce,
        magnetStrength: magnetStrength * 50, // UI scale; mapped back in applyPhysicsSettings
        collisionEnergyLoss: 0.15,
        angularVelocityTransfer: 0.5,
        particleEmissionRate: 5,
        particleLife: 100,
        particleSize: 3,
        explosionParticles: 20,
        trailLength: 10,
        shadowBlur: 15,
        shadowOpacity: 0.5,
        trailOpacity: 0.3,
        glowIntensity: 1.0,
        timeScale: 1.0
    };
    
    function applyPhysicsSettings() {
        gravity = physicsSettings.gravity;
        airResistance = physicsSettings.airResistance;
        angularDamping = physicsSettings.angularDamping;
        restitution = physicsSettings.restitution;
        friction = physicsSettings.friction;
        wallBounce = physicsSettings.wallBounce;
        magnetStrength = physicsSettings.magnetStrength / 50;
    }
    
    // Initialize to Normal Bounciness by default (no energy loss)
    physicsSettings.restitution = 1.0;
    physicsSettings.wallBounce = 1.0;
    physicsSettings.collisionEnergyLoss = 0.0;
    applyPhysicsSettings();
    
    // === Target size for shrink/grow modes ===
    let targetSize = { width: blockSize, height: blockSize };
    
    // === Effect flags ===
    let rainbowMode = false;
    let shrinkMode = false;
    let growMode = false;
    let trailMode = false;
    let flashMode = false;
    let colorCycle = false;
    let randomFrameColors = false;
    let gravityWave = false;
    let gravitySpin = false;
    let magnetize = false;
    let magnetInvert = false;
    let centerPull = false;
    let verticalMovement = true;
    let horizontalMovement = true;
    let slowMo = 1;
    let rotateMode = false;
    let tornadoMode = false;
    let sizeWaveMode = false;
    let antiGravityMode = false;
    
    // === Color Pulsing System ===
    let colorPulseMode = false;
    let menuPulseMode = false;
    let pulseColor1 = '#ff595e';
    let pulseColor2 = '#1982c4';
    let pulsePhase = 0;
    let menuPulsePhase = 0;
    let pulseSpeed = 0.05;
    let menuPulseSpeed = 0.03;
    
    // === Particle Effects System ===
    let flamingParticlesActive = false;
    let mouseTrailActive = false;
    let snowfallActive = false;
    let sparklerActive = false;
    let starfieldActive = false;
    let rainActive = false;
    let bubblesActive = false;
    let fireworksActive = false;
    let smokeTrailActive = false;
    let electricityActive = false;
    let pixelDustActive = false;
    let cosmicWindActive = false;
    let auroraActive = false;
    let plasmaActive = false;
    let nebulaDriftActive = false;
    
    // === Illusion flags ===
    let illusionsActive = {
        spiral: false,
        breathingGrid: false,
        waveTunnel: false,
        vortex: false,
        orbitRing: false,
        checkerSpin: false,
        flipStrip: false,
        zoomPulse: false,
        swirlField: false,
        hypnoHue: false
    };
    
    // === Sound cooldown system ===
    const soundCooldowns = {
        bounce: 0,
        collision: 0,
        rolling: 0
    };
    const SOUND_COOLDOWN_TIME = 100;
    
    const defaultSettings = {
        gravity: 0.6,
        friction: 0.85,
        wallBounce: 0.75,
        restitution: 0.8,
        blockSize: 100,
        gravityDir: 1,
        magnetStrength: 3
    };
    
    const colors = ['#ff595e', '#8ac926', '#1982c4', '#ffca3a', '#6a4c93'];
    const shapes = ['rectangle', 'circle', 'triangle'];
    
    // === OPTIMIZATION: Create spatial grid ===
    const spatialGrid = new SpatialGrid(performanceSettings.spatialGridSize);
    let frameCount = 0;
    
    // === Block factory ===
    function makeBlock(x, y, color = randomColor(), shape = randomShape()) {
        const mass = 1;
        return {
            x,
            y,
            w: blockSize,
            h: blockSize,
            color,
            vx: (Math.random() - 0.5) * 2,
            vy: 0,
            isDragging: false,
            shape,
            mass,
            rotation: 0,
            rotationSpeed: (Math.random() - 0.5) * 0.1,
            angularVelocity: 0,
            displayW: blockSize,
            displayH: blockSize,
            elasticity: restitution,
            friction,
            momentOfInertia: (mass * (blockSize * blockSize + blockSize * blockSize)) / 12,
            trail: [],
            maxTrailLength: 20
        };
    }
    
    // Start with exactly 3 shapes
    const blocks = [
        makeBlock(200, 100, colors[0], 'rectangle'),
        makeBlock(360, 100, colors[1], 'circle'),
        makeBlock(520, 100, colors[2], 'triangle')
    ];
    
    const activeCollisions = new Set();
    const dynamites = [];
    const particles = [];
    const effectParticles = [];
    
    // Mouse positions
    let mouseX = 0;
    let mouseY = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let prevMouseX = 0;
    let prevMouseY = 0;
    
    function makeDynamite(x, y) {
        return {
            x,
            y,
            vx: 0,
            vy: 0,
            w: 20,
            h: 50,
            timer: 180,
            exploded: false,
            color: 'red',
            isDragging: false
        };
    }
    
    // === OPTIMIZATION: Particle pooling ===
    const particlePool = [];
    
    function makeParticle(x, y, color) {
        // Try to reuse from pool
        if (particlePool.length > 0) {
            const particle = particlePool.pop();
            particle.x = x;
            particle.y = y;
            particle.vx = (Math.random() - 0.5) * 15;
            particle.vy = (Math.random() - 0.5) * 15;
            particle.life = 100;
            particle.color = color;
            particle.size = Math.random() * 6 + 2;
            particle.gravity = 0.2;
            particle.airResistance = 0.98;
            return particle;
        }
        
        // Create new if pool is empty
        return {
            x,
            y,
            vx: (Math.random() - 0.5) * 15,
            vy: (Math.random() - 0.5) * 15,
            life: 100,
            color,
            size: Math.random() * 6 + 2,
            gravity: 0.2,
            airResistance: 0.98
        };
    }
    
    // === Effect particles factory ===
    function makeEffectParticle(type, x, y) {
        const base = { x, y, life: 100, maxLife: 100, size: 2, type };
        
        switch (type) {
            case 'flame':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 3,
                    vy: -Math.random() * 4 - 2,
                    color: `hsl(${Math.random() * 60},100%,${50 + Math.random() * 30}%)`,
                    size: Math.random() * 10 + 4,
                    life: 80,
                    gravity: -0.1
                };
            case 'mouseTrail':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 1,
                    vy: (Math.random() - 0.5) * 1,
                    color: `hsl(${Math.random() * 360},70%,60%)`,
                    size: Math.random() * 8 + 3,
                    life: 40,
                    gravity: 0
                };
            case 'snow':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 0.8,
                    vy: Math.random() * 1.5 + 0.5,
                    color: '#ffffff',
                    size: Math.random() * 5 + 2,
                    life: 400,
                    gravity: 0.05
                };
            case 'sparkle':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    color: `hsl(${Math.random() * 60 + 40},100%,80%)`,
                    size: Math.random() * 4 + 1,
                    life: 50,
                    twinkle: Math.random() * Math.PI * 2,
                    gravity: 0
                };
            case 'star':
                return {
                    ...base,
                    vx: 0,
                    vy: Math.random() * 0.8 + 0.2,
                    color: `hsl(${Math.random() * 60 + 200},70%,80%)`,
                    size: Math.random() * 3 + 1,
                    life: 600,
                    gravity: 0.01
                };
            case 'rain':
                return {
                    ...base,
                    vx: Math.random() * 3 - 1,
                    vy: Math.random() * 10 + 8,
                    color: 'rgba(100,150,255,0.7)',
                    size: Math.random() * 3 + 1,
                    life: 200,
                    gravity: 0.3
                };
            case 'bubble':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: -Math.random() * 3 - 1,
                    color: `hsla(${Math.random() * 60 + 180},50%,80%,0.3)`,
                    size: Math.random() * 18 + 7,
                    life: 250,
                    float: Math.random() * Math.PI * 2,
                    gravity: -0.05
                };
            case 'firework':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    color: `hsl(${Math.random() * 360},100%,60%)`,
                    size: Math.random() * 5 + 2,
                    life: 100,
                    gravity: 0.15,
                    airResistance: 0.97
                };
            case 'smoke':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: -Math.random() * 3 - 1,
                    color: `rgba(100,100,100,${0.5 - Math.random() * 0.3})`,
                    size: Math.random() * 12 + 6,
                    life: 120,
                    gravity: -0.02,
                    airResistance: 0.95
                };
            case 'electric':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    color: `hsl(${Math.random() * 60 + 180},100%,80%)`,
                    size: Math.random() * 4 + 1,
                    life: 25,
                    intensity: Math.random(),
                    gravity: 0,
                    airResistance: 0.9
                };
            case 'pixelDust':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: `hsl(${Math.random() * 360},80%,70%)`,
                    size: 2,
                    life: 150,
                    gravity: 0.05
                };
            case 'cosmic':
                return {
                    ...base,
                    vx: Math.random() * 4 + 2,
                    vy: (Math.random() - 0.5) * 1.5,
                    color: `hsl(${Math.random() * 60 + 280},70%,60%)`,
                    size: Math.random() * 4 + 1,
                    life: 250,
                    gravity: 0.02
                };
            case 'aurora':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 0.8,
                    color: `hsl(${Math.random() * 120 + 120},60%,70%)`,
                    size: Math.random() * 10 + 5,
                    life: 200,
                    wave: Math.random() * Math.PI * 2,
                    gravity: 0,
                    airResistance: 0.98
                };
            case 'plasma':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    color: `hsl(${Math.random() * 60 + 300},80%,70%)`,
                    size: Math.random() * 8 + 4,
                    life: 80,
                    energy: Math.random(),
                    gravity: 0,
                    airResistance: 0.96
                };
            case 'nebula':
                return {
                    ...base,
                    vx: (Math.random() - 0.5) * 0.8,
                    vy: (Math.random() - 0.5) * 0.8,
                    color: `hsl(${Math.random() * 180 + 200},60%,50%)`,
                    size: Math.random() * 15 + 10,
                    life: 350,
                    drift: Math.random() * Math.PI * 2,
                    gravity: 0,
                    airResistance: 0.99
                };
            default:
                return {
                    ...base,
                    vx: 0,
                    vy: 0,
                    color: '#ffffff'
                };
        }
    }
    
    function updateEffectParticles() {
        // Skip particle updates on some frames for performance
        if (frameCount % performanceSettings.particleUpdateInterval !== 0) return;
        
        if (flamingParticlesActive) {
            for (let i = 0; i < 4; i++) {
                const particle = makeEffectParticle('flame', Math.random() * canvas.width, canvas.height + 10);
                effectParticles.push(particle);
            }
        }
        
        if (mouseTrailActive) {
            const particle = makeEffectParticle('mouseTrail', mouseX, mouseY);
            effectParticles.push(particle);
        }
        
        if (snowfallActive) {
            for (let i = 0; i < 3; i++) {
                const particle = makeEffectParticle('snow', Math.random() * canvas.width, -10);
                effectParticles.push(particle);
            }
        }
        
        if (sparklerActive) {
            for (let i = 0; i < 6; i++) {
                const particle = makeEffectParticle(
                    'sparkle',
                    mouseX + (Math.random() - 0.5) * 40,
                    mouseY + (Math.random() - 0.5) * 40
                );
                effectParticles.push(particle);
            }
        }
        
        if (starfieldActive) {
            const particle = makeEffectParticle('star', Math.random() * canvas.width, -10);
            effectParticles.push(particle);
        }
        
        if (rainActive) {
            for (let i = 0; i < 6; i++) {
                const particle = makeEffectParticle('rain', Math.random() * canvas.width, -10);
                effectParticles.push(particle);
            }
        }
        
        if (bubblesActive) {
            const particle = makeEffectParticle('bubble', Math.random() * canvas.width, canvas.height + 10);
            effectParticles.push(particle);
        }
        
        if (fireworksActive && Math.random() < 0.15) {
            const ex = Math.random() * canvas.width;
            const ey = Math.random() * canvas.height * 0.7;
            for (let i = 0; i < 20; i++) {
                const particle = makeEffectParticle('firework', ex, ey);
                effectParticles.push(particle);
            }
        }
        
        if (smokeTrailActive) {
            const particle = makeEffectParticle('smoke', mouseX, mouseY);
            effectParticles.push(particle);
        }
        
        if (electricityActive) {
            for (let i = 0; i < 4; i++) {
                const particle = makeEffectParticle('electric', Math.random() * canvas.width, Math.random() * canvas.height);
                effectParticles.push(particle);
            }
        }
        
        if (pixelDustActive) {
            for (let i = 0; i < 3; i++) {
                const particle = makeEffectParticle(
                    'pixelDust',
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                );
                effectParticles.push(particle);
            }
        }
        
        if (cosmicWindActive) {
            const particle = makeEffectParticle('cosmic', -10, Math.random() * canvas.height);
            effectParticles.push(particle);
        }
        
        if (auroraActive) {
            const particle = makeEffectParticle(
                'aurora',
                Math.random() * canvas.width,
                Math.random() * canvas.height * 0.3
            );
            effectParticles.push(particle);
        }
        
        if (plasmaActive) {
            for (let i = 0; i < 3; i++) {
                const particle = makeEffectParticle('plasma', Math.random() * canvas.width, Math.random() * canvas.height);
                effectParticles.push(particle);
            }
        }
        
        if (nebulaDriftActive) {
            const particle = makeEffectParticle('nebula', Math.random() * canvas.width, Math.random() * canvas.height);
            effectParticles.push(particle);
        }
        
        for (let i = effectParticles.length - 1; i >= 0; i--) {
            const p = effectParticles[i];
            if (p.gravity !== undefined) p.vy += p.gravity;
            if (p.airResistance !== undefined) {
                p.vx *= p.airResistance;
                p.vy *= p.airResistance;
            }
            p.x += p.vx;
            p.y += p.vy;
            
            if (p.type === 'bubble') {
                p.float += 0.1;
                p.x += Math.sin(p.float) * 0.8;
            }
            
            if (p.type === 'sparkle') p.twinkle += 0.3;
            
            if (p.type === 'aurora') {
                p.wave += 0.15;
                p.x += Math.sin(p.wave) * 0.5;
                p.y += Math.cos(p.wave) * 0.2;
            }
            
            if (p.type === 'nebula') {
                p.drift += 0.05;
                p.x += Math.cos(p.drift) * 0.3;
                p.y += Math.sin(p.drift) * 0.3;
            }
            
            if (p.type === 'electric') {
                p.vx += (Math.random() - 0.5) * 2;
                p.vy += (Math.random() - 0.5) * 2;
            }
            
            p.life--;
            
            if (
                p.life <= 0 ||
                p.y > canvas.height + 50 ||
                p.x > canvas.width + 50 ||
                p.x < -50
            ) {
                // Return to pool instead of deleting
                if (particlePool.length < 100) {
                    particlePool.push(p);
                }
                effectParticles.splice(i, 1);
            }
        }
    }
    
    function randomColor() {
        return colors[Math.floor(Math.random() * colors.length)];
    }
    
    function randomShape() {
        return shapes[Math.floor(Math.random() * shapes.length)];
    }
    
    function interpolateColor(color1, color2, factor) {
        const c1 = hexToRgb(color1);
        const c2 = hexToRgb(color2);
        const r = Math.round(c1.r + (c2.r - c1.r) * factor);
        const g = Math.round(c1.g + (c2.g - c1.g) * factor);
        const b = Math.round(c1.b + (c2.b - c1.b) * factor);
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    function hexToRgb(hex) {
        const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return res ? {
            r: parseInt(res[1], 16),
            g: parseInt(res[2], 16),
            b: parseInt(res[3], 16)
        } : {
            r: 255,
            g: 255,
            b: 255
        };
    }
    
    // === X-GUI Style Menu ===
    const gui = document.createElement("div");
    Object.assign(gui.style, {
        position: 'fixed',
        top: '50px',
        left: '50px',
        background: 'var(--background)',
        height: '500px',
        width: '800px',
        color: '#fff',
        padding: '0',
        zIndex: '10000',
        fontSize: '16px',
        borderRadius: '20px',
        overflow: 'hidden',
        boxShadow: '0 0 15px var(--highlight)',
        fontFamily: "'Nunito', sans-serif"
    });
    
    // === CSS Variables for X-GUI Theme ===
    const variables = {
        "--highlight": "#8A2BE2", // Bright purple highlight
        "--highlight2": "#4B0082", // Deep indigo secondary
        "--background": "#0B0B1E", // Dark bluish background
        "--background2": "#151534", // Slightly lighter dark layer
        "--textColor": "#E0E0FF", // Soft light text
        "--textColor2": "#9A8CFF", // Muted purple text
        "--toggleOff": "#2C273F", // Deep shadowy indigo — off
        "--toggleOn": "#5FA3FF" // Muted soft blue — on
    };
    
    for (const variable in variables) {
        gui.style.setProperty(variable, variables[variable]);
    }
    
    // Add animation for glowing border
    const style = document.createElement("style");
    style.textContent = `
        @keyframes edgePulse {
            0% { border-color: var(--highlight); box-shadow: 0 0 10px var(--highlight); }
            50% { border-color: var(--highlight2); box-shadow: 0 0 25px var(--highlight2); }
            100% { border-color: var(--highlight); box-shadow: 0 0 10px var(--highlight); }
        }
        @keyframes glowPulse {
            from { text-shadow: 0 0 10px var(--highlight); }
            to { text-shadow: 0 0 25px var(--highlight2), 0 0 40px var(--highlight); }
        }
        .X-Gui-sidebar {
            transition: width 0.2s 0.1s;
        }
        .X-Gui-sidebar:hover {
            width: 200px !important;
            transition-delay: 0s;
        }
        .X-Gui-sidebarPath {
            transition: padding-left 0.2s 0.1s, color 0.2s;
        }
        .X-Gui-sidebar:hover .X-Gui-sidebarPath {
            padding-left: 20px;
            transition-delay: 0s;
        }
        .X-Gui-bigText {
            transition: margin-top 0.1s, font-size 0.2s 0.1s, margin-block 0.2s 0.1s;
        }
        .X-Gui-sidebar:hover .X-Gui-bigText {
            margin-top: 0;
            transition: margin-top 0.4s 0.1s;
        }
        .X-Gui-sidebar:hover .X-Gui-bigTextContainer {
            font-size: 2.5em;
            margin-block: 20px;
            transition: font-size 0.2s, margin-block 0.2s;
        }
        /* Mobile Mode Overrides */
        body.xgui-mobile-mode .X-Gui-sidebar {
            width: 70px !important;
            overflow: hidden !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 22px !important;
            padding-top: 20px !important;
            padding-bottom: 20px !important;
        }
        body.xgui-mobile-mode .X-Gui-sidebar:hover { width: 70px !important; }
        body.xgui-mobile-mode .X-Gui-sidebar span { display: none !important; }
        body.xgui-mobile-mode .X-Gui-content {
            overflow-y: auto !important;
            max-height: calc(100% - 45px) !important;
            padding-right: 10px !important;
            min-width: 0 !important;
            word-break: break-word !important;
        }
    `;
    document.head.appendChild(style);
    
    gui.style.border = '2px solid var(--highlight)';
    gui.style.animation = 'edgePulse 2s ease-in-out infinite';
    
    // Create after element for border glow
    const borderGlow = document.createElement("div");
    Object.assign(borderGlow.style, {
        content: '""',
        position: 'absolute',
        inset: '0',
        borderRadius: '20px',
        border: '2px solid var(--highlight)',
        pointerEvents: 'none',
        animation: 'edgePulse 2s ease-in-out infinite'
    });
    gui.appendChild(borderGlow);
    
    document.body.appendChild(gui);
    
    // === Controls Bar ===
    const controls = document.createElement("div");
    Object.assign(controls.style, {
        position: 'absolute',
        top: '0',
        right: '0',
        display: 'grid',
        gridTemplateColumns: '1fr 1fr 1fr',
        height: '25px',
        width: '122px',
        gap: '1px',
        border: '1px solid var(--background)',
        zIndex: '2',
        background: '#FFFFFF', // CHANGED: White background for controls bar
        borderRadius: '0 0 0 12px' // Optional: Round bottom-left corner slightly
    });
    
    const moveControl = document.createElement("div");
    moveControl.style.cursor = "grab";
    moveControl.innerHTML = '<i class="fas fa-arrows-alt-h" style="line-height: 1; color: #000;"></i>'; // CHANGED: Black icon
    Object.assign(moveControl.style, {
        display: 'grid',
        placeItems: 'center',
        fontWeight: '100',
        background: 'transparent' // Transparent to see white bar
    });
    
    const minimizeControl = document.createElement("div");
    // CHANGED: Use "o" for minimize and "O" for restore
    minimizeControl.innerHTML = '<span style="line-height: 1; color: #000; font-family: monospace; font-weight: bold;">o</span>';
    Object.assign(minimizeControl.style, {
        display: 'grid',
        placeItems: 'center',
        fontWeight: '100',
        background: 'transparent'
    });
    
    let hideAnimation = false;
    minimizeControl.onclick = () => {
        if (hideAnimation == (hideAnimation = true)) return;
        const hidden = minimizeControl.minimized;
        if (hidden) {
            // Restore State (showing content) -> Icon becomes "o"
            minimizeControl.innerHTML = '<span style="line-height: 1; color: #000; font-family: monospace; font-weight: bold;">o</span>';
            gui.animate([
                { width: "122px", height: "27px", left: gui.style.left },
                { width: "800px", height: "500px", left: `${parseInt(gui.style.left) + (hidden ? -678 : 678)}px` }
            ], { duration: 200, easing: "ease" });
            gui.style.width = "800px";
            gui.style.height = "500px";
        } else {
            // Minimize State (showing only bar) -> Icon becomes "O" (capital)
            minimizeControl.innerHTML = '<span style="line-height: 1; color: #000; font-family: monospace; font-weight: bold;">O</span>';
            gui.animate([
                { width: "800px", height: "500px", left: gui.style.left },
                { width: "122px", height: "27px", left: `${parseInt(gui.style.left) + (hidden ? -678 : 678)}px` }
            ], { duration: 200, easing: "ease" });
            gui.style.width = "122px";
            gui.style.height = "27px";
        }
        setTimeout(() => {
            for (let child of [...gui.children]) {
                if (child == controls) continue;
                if (hidden) child.style.display = child.style._display;
                else {
                    child.style._display = child.style.display;
                    child.style.display = "none";
                }
            }
            hideAnimation = false;
        }, hidden ? 200 : 0);
        gui.style.left = `${parseInt(gui.style.left) + (hidden ? -678 : 678)}px`;
        minimizeControl.minimized = !hidden;
    };
    
    const closeControl = document.createElement("div");
    // CHANGED: Just "x"
    closeControl.innerHTML = '<span style="line-height: 1; color: #000; font-family: monospace; font-weight: bold;">x</span>';
    Object.assign(closeControl.style, {
        display: 'grid',
        placeItems: 'center',
        fontWeight: '100',
        background: 'transparent',
        transition: '0.1s'
    });
    closeControl.onmouseover = () => closeControl.style.background = '#ff4444'; // Red on hover
    closeControl.onmouseout = () => closeControl.style.background = 'transparent';
    closeControl.onclick = () => gui.remove();
    
    controls.append(moveControl, minimizeControl, closeControl);
    gui.appendChild(controls);
    
    // === Drag Functionality ===
    function dragElement(element, parent) {
        var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        element.onpointerdown = function(e = window.event) {
            element.style.cursor = "grabbing";
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onpointerup = function() {
                element.style.cursor = "grab";
                document.onpointerup = null;
                document.onpointermove = null;
            };
            document.onpointermove = function(e = window.event) {
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                parent.style.top = parent.offsetTop - pos2 + "px";
                parent.style.left = parent.offsetLeft - pos1 + "px";
            };
        };
    }
    
    dragElement(moveControl, gui);
    
    // === Sidebar ===
    const sidebar = document.createElement("div");
    sidebar.className = "X-Gui-sidebar"; // Add class for mobile CSS targeting
    Object.assign(sidebar.style, {
        position: 'absolute',
        top: '0',
        left: '0',
        height: '100%',
        width: '50px',
        transition: '0.2s 0.1s',
        zIndex: '10',
        overflowX: 'hidden',
        padding: '0',
        background: 'var(--background2)'
    });
    
    // Add hover effect to expand sidebar
    sidebar.addEventListener('mouseenter', () => {
        sidebar.style.width = '200px';
    });
    
    sidebar.addEventListener('mouseleave', () => {
        sidebar.style.width = '50px';
    });
    
    gui.appendChild(sidebar);
    
    // === Sidebar Paths ===
    const sidebarPaths = document.createElement("div");
    Object.assign(sidebarPaths.style, {
        display: 'flex',
        flexDirection: 'column',
        width: '200px'
    });
    sidebar.appendChild(sidebarPaths);
    
    // === Big Text Container ===
    const bigTextContainer = document.createElement("div");
    bigTextContainer.className = "X-Gui-bigTextContainer";
    Object.assign(bigTextContainer.style, {
        display: 'flex',
        fontSize: '2em',
        marginBlock: '10px',
        alignItems: 'center',
        userSelect: 'none'
    });
    
    const dummyK = document.createElement("span");
    dummyK.innerText = "X";
    Object.assign(dummyK.style, {
        opacity: '0'
    });
    
    const bigText = document.createElement("span");
    bigText.innerText = "-Physics";
    bigText.className = "X-Gui-bigText";
    Object.assign(bigText.style, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '50px',
        width: '200px',
        fontFamily: 'Titan One',
        textShadow: '0 0 10px var(--highlight), 0 0 20px var(--highlight2)',
        animation: 'glowPulse 2s ease-in-out infinite alternate'
    });
    
    const logo = document.createElement("span");
    logo.innerHTML = "X";
    Object.assign(logo.style, {
        width: '50px',
        height: '50px',
        display: 'grid',
        placeItems: 'center',
        minWidth: '50px',
        position: 'absolute',
        left: '0',
        transition: 'left 0.2s 0.1s'
    });
    
    bigTextContainer.append(logo, dummyK, bigText);
    sidebar.prepend(bigTextContainer);
    
    // === GUI Content (Main Container) ===
    const guiContent = document.createElement("div");
    guiContent.className = "X-Gui-content";
    Object.assign(guiContent.style, {
        position: 'absolute',
        inset: '20px',
        left: '70px',
        top: '40px',
        zIndex: '1',
        paddingTop: '32px',
        background: 'var(--background2)'
    });
    gui.appendChild(guiContent);
    
    // === Path Text ===
    const pathText = document.createElement("div");
    Object.assign(pathText.style, {
        position: 'absolute',
        top: '40px',
        left: '70px',
        right: '20px',
        zIndex: '3',
        padding: '7px 10px',
        height: '22px',
        background: 'var(--background2)',
        color: 'var(--textColor)'
    });
    pathText.innerText = "Physics Controls";
    gui.appendChild(pathText);
    
    // === Refresh Control ===
    const refreshControl = document.createElement("div");
    refreshControl.innerHTML = '<i class="fas fa-sync" style="line-height: 1"></i>';
    Object.assign(refreshControl.style, {
        position: 'absolute',
        top: '45px',
        right: '25px',
        width: '25px',
        height: '25px',
        display: 'grid',
        placeItems: 'center',
        cursor: 'pointer',
        zIndex: '5'
    });
    refreshControl.onclick = () => {
        refreshControl.animate([
            { rotate: "0deg" },
            { rotate: "360deg" }
        ], { duration: 1000, easing: "ease" });
    };
    gui.appendChild(refreshControl);
    
    // === Content Pages ===
    const contentPages = {
        core: document.createElement("div"),
        color: document.createElement("div"),
        particle: document.createElement("div"),
        fun: document.createElement("div"),
        physics: document.createElement("div"),
        illusions: document.createElement("div"),
        settings: document.createElement("div") // Added Settings Page
    };
    
    // Style content pages
    Object.values(contentPages).forEach(page => {
        Object.assign(page.style, {
            position: 'absolute',
            inset: '0',
            top: '35px',
            background: 'var(--background2)',
            overflowY: 'auto',
            padding: '10px',
            display: 'none', // Hidden by default
            flexDirection: 'column',
            gap: '10px'
        });
        guiContent.appendChild(page); // ADD TO DOM HERE
    });
    
    // === UI Helpers ===
    function createButton(text, onClick) {
        const btn = document.createElement('button');
        btn.innerText = text;
        Object.assign(btn.style, {
            background: 'var(--background)',
            color: 'var(--textColor)',
            border: '2px solid var(--highlight)',
            padding: '8px 12px',
            cursor: 'pointer',
            borderRadius: '5px',
            fontSize: '14px',
            fontWeight: '700',
            transition: 'all 0.2s',
            width: '100%'
        });
        
        btn.onmouseover = () => {
            btn.style.background = 'var(--highlight)';
            btn.style.boxShadow = '0 0 10px 0 var(--highlight)';
        };
        
        btn.onmouseout = () => {
            btn.style.background = 'var(--background)';
            btn.style.boxShadow = 'none';
        };
        
        btn.onclick = () => {
            playSound('click');
            onClick();
        };
        
        return btn;
    }
    
    function createSlider(labelText, min, max, step, value, onInput) {
        const container = document.createElement('div');
        Object.assign(container.style, {
            display: 'flex',
            flexDirection: 'column',
            gap: '5px',
            padding: '8px',
            background: 'var(--background)',
            borderRadius: '5px'
        });
        
        const label = document.createElement('label');
        label.innerText = `${labelText}: ${value}`;
        Object.assign(label.style, {
            color: 'var(--textColor)',
            fontSize: '14px',
            fontWeight: '700'
        });
        
        const input = document.createElement('input');
        input.type = 'range';
        input.min = min;
        input.max = max;
        input.step = step;
        input.value = value;
        Object.assign(input.style, {
            width: '100%',
            height: '25px',
            outline: '0',
            border: '2px solid var(--highlight)',
            boxSizing: 'border-box',
            background: 'var(--background2)',
            color: '#fff',
            fontSize: '14px',
            fontFamily: 'Nunito',
            borderRadius: '2px',
            fontWeight: '800'
        });
        
        input.oninput = (e) => {
            const val = parseFloat(e.target.value);
            label.innerText = `${labelText}: ${val.toFixed(2)}`;
            onInput(val);
        };
        
        container.appendChild(label);
        container.appendChild(input);
        
        return { container, input, label };
    }
    
    function createToggle(name, initialState, onChange) {
        const container = document.createElement('div');
        Object.assign(container.style, {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            padding: '10px',
            background: 'var(--background)',
            borderRadius: '5px',
            marginBottom: '5px'
        });
        
        const label = document.createElement('span');
        label.innerText = name;
        Object.assign(label.style, {
            color: 'var(--textColor)',
            fontSize: '14px',
            fontWeight: '700'
        });
        
        const toggle = document.createElement('div');
        Object.assign(toggle.style, {
            width: '50px',
            height: '25px',
            background: initialState ? 'var(--toggleOn)' : 'var(--toggleOff)',
            borderRadius: '12px',
            position: 'relative',
            cursor: 'pointer',
            transition: 'background 0.3s'
        });
        
        const handle = document.createElement('div');
        Object.assign(handle.style, {
            width: '21px',
            height: '21px',
            background: '#fff',
            borderRadius: '50%',
            position: 'absolute',
            top: '2px',
            left: initialState ? '27px' : '2px',
            transition: 'left 0.3s',
            boxShadow: '0 0 5px rgba(0,0,0,0.3)'
        });
        
        toggle.appendChild(handle);
        
        toggle.onclick = () => {
            const newState = !initialState;
            initialState = newState;
            toggle.style.background = newState ? 'var(--toggleOn)' : 'var(--toggleOff)';
            handle.style.left = newState ? '27px' : '2px';
            onChange(newState);
        };
        
        container.appendChild(label);
        container.appendChild(toggle);
        
        return container;
    }
    
    // === Core Controls Page ===
    const coreControls = [
        createButton('Spawn Shape', () => {
            blocks.push(makeBlock(Math.random() * (canvas.width - blockSize), 0));
            playSound('whoosh');
        }),
        createButton('Remove All Shapes', () => {
            blocks.splice(0, blocks.length);
        }),
        createButton('Teleport Random', () => {
            blocks.forEach((b) => {
                b.x = Math.random() * (canvas.width - b.w);
                b.y = Math.random() * (canvas.height - b.h);
                b.vx = (Math.random() - 0.5) * 5;
                b.vy = (Math.random() - 0.5) * 5;
            });
            playSound('whoosh');
        }),
        createToggle('Collisions', collisionsEnabled, (state) => {
            collisionsEnabled = state;
        }),
        createToggle('Trail Mode', trailMode, (state) => {
            trailMode = state;
        }),
        createToggle('Rainbow Mode', rainbowMode, (state) => {
            rainbowMode = state;
            if (rainbowMode) colorPulseMode = false;
        })
    ];
    
    coreControls.forEach(control => contentPages.core.appendChild(control));
    
    // Add gravity and friction sliders
    const gravitySlider = createSlider('Gravity', 0, 3, 0.1, physicsSettings.gravity, (v) => {
        physicsSettings.gravity = v;
        applyPhysicsSettings();
    });
    contentPages.core.appendChild(gravitySlider.container);
    
    const frictionSlider = createSlider('Friction', 0, 1, 0.05, physicsSettings.friction, (v) => {
        physicsSettings.friction = v;
        applyPhysicsSettings();
    });
    contentPages.core.appendChild(frictionSlider.container);
    
    // === Color Controls Page ===
    function createColorSpectrum(label, initialColor, callback) {
        const spectrum = document.createElement('div');
        spectrum.className = 'color-spectrum';
        Object.assign(spectrum.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'rgba(0,0,0,0.95)',
            border: '2px solid var(--highlight)',
            borderRadius: '10px',
            padding: '20px',
            zIndex: '10001',
            display: 'none',
            boxShadow: '0 0 20px rgba(0,255,0,0.5)',
            flexDirection: 'column',
            gap: '10px',
            alignItems: 'center' // Center items horizontally
        });
        
        const spectrumLabel = document.createElement('div');
        spectrumLabel.textContent = label;
        Object.assign(spectrumLabel.style, {
            color: 'var(--textColor)',
            textAlign: 'center',
            marginBottom: '10px',
            fontWeight: 'bold'
        });
        
        const preview = document.createElement('div');
        Object.assign(preview.style, {
            width: '50px',
            height: '50px',
            border: '2px solid var(--highlight)',
            borderRadius: '5px',
            margin: '10px auto',
            backgroundColor: initialColor
        });
        
        const spectrumCanvas = document.createElement('canvas');
        Object.assign(spectrumCanvas.style, {
            border: '1px solid var(--highlight)',
            borderRadius: '5px',
            cursor: 'crosshair',
            margin: '10px 0'
        });
        spectrumCanvas.width = 300;
        spectrumCanvas.height = 200;
        
        // --- NEW VISIBLE CLOSE BUTTON ---
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'X'; // Text is just 'X'
        Object.assign(closeBtn.style, {
            background: '#ff4444', // Visible red background
            color: '#ffffff',      // White text
            border: '1px solid #ff8888',
            padding: '8px 16px',   // Good size for touch
            cursor: 'pointer',
            borderRadius: '5px',
            fontWeight: 'bold',
            fontSize: '16px',
            marginTop: '5px',
            width: '100%' // Take full width of container
        });
        
        spectrum.appendChild(spectrumLabel);
        spectrum.appendChild(preview);
        spectrum.appendChild(spectrumCanvas);
        spectrum.appendChild(closeBtn);
        document.body.appendChild(spectrum);
        
        const sctx = spectrumCanvas.getContext('2d');
        for (let x = 0; x < spectrumCanvas.width; x++) {
            for (let y = 0; y < spectrumCanvas.height; y++) {
                const hue = (x / spectrumCanvas.width) * 360;
                const lightness = 100 - (y / spectrumCanvas.height) * 100;
                sctx.fillStyle = `hsl(${hue},100%,${lightness}%)`;
                sctx.fillRect(x, y, 1, 1);
            }
        }
        
        spectrumCanvas.addEventListener('click', (e) => {
            const rect = spectrumCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const hue = (x / spectrumCanvas.width) * 360;
            const lightness = 100 - (y / spectrumCanvas.height) * 100;
            const selected = `hsl(${hue},100%,${lightness}%)`;
            const rgb = hslToRgb(hue, 100, lightness);
            const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
            preview.style.backgroundColor = selected;
            callback(hex);
        });
        
        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = (n) => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = (n) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return {
                r: Math.round(255 * f(0)),
                g: Math.round(255 * f(8)),
                b: Math.round(255 * f(4))
            };
        }
        
        function rgbToHex(r, g, b) {
            return (
                '#' + ((1 << 24) + (r << 16) + (g << 8) + b)
                .toString(16)
                .slice(1)
            );
        }
        
        closeBtn.onclick = () => {
            spectrum.style.display = 'none';
        };
        
        return spectrum;
    }
    
    const color1Spectrum = createColorSpectrum('Select Color 1', pulseColor1, (color) => {
        pulseColor1 = color;
        color1Btn.style.background = color;
        color1Btn.style.color = '#fff';
    });
    
    const color2Spectrum = createColorSpectrum('Select Color 2', pulseColor2, (color) => {
        pulseColor2 = color;
        color2Btn.style.background = color;
        color2Btn.style.color = '#fff';
    });
    
    const color1Btn = createButton('Color 1', () => {
        color1Spectrum.style.display = 'flex'; // Use flex to match container
    });
    color1Btn.style.background = pulseColor1;
    color1Btn.style.color = '#fff';
    
    const color2Btn = createButton('Color 2', () => {
        color2Spectrum.style.display = 'flex'; // Use flex to match container
    });
    color2Btn.style.background = pulseColor2;
    color2Btn.style.color = '#fff';
    
    const pulseSpeedSlider = createSlider('Pulse Speed', 0.0025, 0.2, 0.0025, pulseSpeed, (v) => {
        pulseSpeed = v;
    });
    
    const togglePulseBtn = createButton('Toggle Shape Pulse', () => {
        colorPulseMode = !colorPulseMode;
        if (!colorPulseMode) {
            blocks.forEach((b, i) => {
                b.color = colors[i % colors.length];
            });
        }
    });
    
    contentPages.color.appendChild(color1Btn);
    contentPages.color.appendChild(color2Btn);
    contentPages.color.appendChild(pulseSpeedSlider.container);
    contentPages.color.appendChild(togglePulseBtn);
    
    // === Additional Color Controls ===
    const backgroundColorBtn = createButton('Background Color', () => {
        const bgSpectrum = createColorSpectrum('Select Background Color', gui.style.getPropertyValue('--background'), (color) => {
            gui.style.setProperty('--background', color);
            bgSpectrum.style.display = 'none';
        });
        bgSpectrum.style.display = 'flex';
    });
    
    const highlightColorBtn = createButton('Highlight Color', () => {
        const highlightSpectrum = createColorSpectrum('Select Highlight Color', gui.style.getPropertyValue('--highlight'), (color) => {
            gui.style.setProperty('--highlight', color);
            highlightSpectrum.style.display = 'none';
        });
        highlightSpectrum.style.display = 'flex';
    });
    
    contentPages.color.appendChild(backgroundColorBtn);
    contentPages.color.appendChild(highlightColorBtn);
    
    // === Particle Effects Page ===
    const particleButtons = [
        ['Flaming Particles', () => { flamingParticlesActive = !flamingParticlesActive; }],
        ['Mouse Trail', () => { mouseTrailActive = !mouseTrailActive; }],
        ['Snowfall', () => { snowfallActive = !snowfallActive; }],
        ['Sparkler', () => { sparklerActive = !sparklerActive; }],
        ['Starfield', () => { starfieldActive = !starfieldActive; }],
        ['Rain', () => { rainActive = !rainActive; }],
        ['Bubbles', () => { bubblesActive = !bubblesActive; }],
        ['Fireworks', () => { fireworksActive = !fireworksActive; }],
        ['Smoke Trail', () => { smokeTrailActive = !smokeTrailActive; }],
        ['Electricity', () => { electricityActive = !electricityActive; }],
        ['Pixel Dust', () => { pixelDustActive = !pixelDustActive; }],
        ['Cosmic Wind', () => { cosmicWindActive = !cosmicWindActive; }],
        ['Aurora', () => { auroraActive = !auroraActive; }],
        ['Plasma', () => { plasmaActive = !plasmaActive; }],
        ['Nebula Drift', () => { nebulaDriftActive = !nebulaDriftActive; }],
        ['Clear All Effects', () => {
            flamingParticlesActive = mouseTrailActive = snowfallActive = sparklerActive = starfieldActive = rainActive = bubblesActive = fireworksActive = smokeTrailActive = electricityActive = pixelDustActive = cosmicWindActive = auroraActive = plasmaActive = nebulaDriftActive = false;
            effectParticles.splice(0, effectParticles.length);
        }]
    ];
    
    particleButtons.forEach(([name, action]) => {
        const btn = createButton(name, action);
        contentPages.particle.appendChild(btn);
    });
    
    // === Fun Controls Page ===
    const funButtons = [
        ['Confetti Explosion', () => {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            for (let i = 0; i < 60; i++) {
                const particle = makeParticle(cx, cy, randomColor());
                particles.push(particle);
            }
            playSound('explosion');
        }],
        ['Dynamite', () => {
            dynamites.push(makeDynamite(canvas.width / 2, 100));
            playSound('whoosh');
        }],
        ['Tornado Mode', () => { tornadoMode = !tornadoMode; }],
        ['Rotate Shapes', () => {
            rotateMode = !rotateMode;
            if (rotateMode) {
                blocks.forEach((b) => {
                    b.rotationSpeed = (Math.random() - 0.5) * 0.15;
                });
            }
        }],
        ['Size Wave', () => {
            sizeWaveMode = !sizeWaveMode;
            if (!sizeWaveMode) {
                blocks.forEach((b) => {
                    b.w = blockSize;
                    b.h = blockSize;
                    b.displayW = blockSize;
                    b.displayH = blockSize;
                });
            }
        }],
        ['Anti-Gravity', () => { antiGravityMode = !antiGravityMode; }],
        ['Black Hole', () => {
            centerPull = true;
            magnetStrength = 8;
            setTimeout(() => {
                centerPull = false;
                magnetStrength = 3;
            }, 4000);
        }],
        ['Shock Wave', () => {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            blocks.forEach((b) => {
                const dx = (b.x + b.w / 2) - cx;
                const dy = (b.y + b.h / 2) - cy;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = 35;
                b.vx = (dx / dist) * force;
                b.vy = (dy / dist) * force;
                b.angularVelocity = (Math.random() - 0.5) * 0.2;
            });
            playSound('explosion');
        }],
        ['Bounce Party', () => {
            blocks.forEach((b) => {
                b.vx = (Math.random() - 0.5) * 30;
                b.vy = (Math.random() - 0.5) * 30;
                b.angularVelocity = (Math.random() - 0.5) * 0.15;
            });
            playSound('whoosh');
        }]
    ];
    
    funButtons.forEach(([name, action]) => {
        const btn = createButton(name, action);
        contentPages.fun.appendChild(btn);
    });
    
    // === Physics Settings Page ===
    function addPhysicsSlider(label, key, min, max, step) {
        const { container, input, label: lbl } = createSlider(
            label,
            min,
            max,
            step,
            physicsSettings[key],
            (v) => {
                physicsSettings[key] = v;
                applyPhysicsSettings();
            }
        );
        
        input.oninput = (e) => {
            const val = parseFloat(e.target.value);
            physicsSettings[key] = val;
            lbl.innerText = `${label}: ${val.toFixed(2)}`;
            applyPhysicsSettings();
        };
        
        contentPages.physics.appendChild(container);
        return { input, lbl };
    }
    
    const gravCtrl = addPhysicsSlider('Gravity', 'gravity', 0, 3, 0.05);
    const airCtrl = addPhysicsSlider('Air Resistance', 'airResistance', 0.9, 1.0, 0.001);
    const angCtrl = addPhysicsSlider('Angular Damping', 'angularDamping', 0.9, 1.0, 0.005);
    const restCtrl = addPhysicsSlider('Restitution', 'restitution', 0, 1, 0.02);
    const fricCtrl = addPhysicsSlider('Collision Friction', 'friction', 0.5, 1, 0.01);
    const wallCtrl = addPhysicsSlider('Wall Bounce', 'wallBounce', 0, 1, 0.02);
    
    // Physics Presets
    const presetsLabel = document.createElement('div');
    presetsLabel.innerText = 'Presets:';
    Object.assign(presetsLabel.style, {
        color: 'var(--textColor)',
        fontSize: '16px',
        fontWeight: '800',
        marginTop: '15px',
        marginBottom: '5px'
    });
    contentPages.physics.appendChild(presetsLabel);
    
    function applyPreset(p) {
        Object.keys(p).forEach((k) => {
            if (k in physicsSettings) physicsSettings[k] = p[k];
        });
        applyPhysicsSettings();
        
        gravCtrl.input.value = physicsSettings.gravity;
        gravCtrl.lbl.innerText = `Gravity: ${physicsSettings.gravity.toFixed(2)}`;
        
        airCtrl.input.value = physicsSettings.airResistance;
        airCtrl.lbl.innerText = `Air Resistance: ${physicsSettings.airResistance.toFixed(3)}`;
        
        angCtrl.input.value = physicsSettings.angularDamping;
        angCtrl.lbl.innerText = `Angular Damping: ${physicsSettings.angularDamping.toFixed(3)}`;
        
        restCtrl.input.value = physicsSettings.restitution;
        restCtrl.lbl.innerText = `Restitution: ${physicsSettings.restitution.toFixed(2)}`;
        
        fricCtrl.input.value = physicsSettings.friction;
        fricCtrl.lbl.innerText = `Collision Friction: ${physicsSettings.friction.toFixed(2)}`;
        
        wallCtrl.input.value = physicsSettings.wallBounce;
        wallCtrl.lbl.innerText = `Wall Bounce: ${physicsSettings.wallBounce.toFixed(2)}`;
    }
    
    const presetButtons = [
        ['Normal Bounciness', {
            restitution: 1.0,
            wallBounce: 1.0,
            collisionEnergyLoss: 0.0
        }],
        ['Space', {
            gravity: 0,
            airResistance: 1,
            restitution: 0.95,
            collisionEnergyLoss: 0.05
        }],
        ['Water', {
            gravity: 0.2,
            airResistance: 0.95,
            restitution: 0.3,
            collisionEnergyLoss: 0.2
        }],
        ['Bouncy', {
            restitution: 0.95,
            friction: 0.98,
            wallBounce: 0.95,
            collisionEnergyLoss: 0.05
        }],
        ['Sticky', {
            restitution: 0.1,
            friction: 0.5,
            wallBounce: 0.3,
            collisionEnergyLoss: 0.4
        }]
    ];
    
    presetButtons.forEach(([name, settings]) => {
        const btn = createButton(name, () => applyPreset(settings));
        contentPages.physics.appendChild(btn);
    });
    
    // === Illusions Page ===
    const illusionButtons = [
        ['Spiral (BW)', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.spiral = true;
        }],
        ['Breathing Grid', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.breathingGrid = true;
        }],
        ['Wave Tunnel', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.waveTunnel = true;
        }],
        ['Vortex Swirl', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.vortex = true;
        }],
        ['Orbit Rings', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.orbitRing = true;
        }],
        ['Checker Spin', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.checkerSpin = true;
        }],
        ['Flip Strip', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.flipStrip = true;
        }],
        ['Zoom Pulse', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.zoomPulse = true;
        }],
        ['Swirl Field (Cursor)', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
            illusionsActive.swirlField = true;
        }],
        ['Hypno Hue (Color Only)', () => {
            illusionsActive.hypnoHue = !illusionsActive.hypnoHue;
        }],
        ['Clear Illusions', () => {
            Object.keys(illusionsActive).forEach(k => illusionsActive[k] = false);
        }]
    ];
    
    illusionButtons.forEach(([name, action]) => {
        const btn = createButton(name, action);
        contentPages.illusions.appendChild(btn);
    });
    
    // === Settings Page (Integration of Theme/Keybind/Mobile Logic) ===
    
    // --- Settings: Mobile Mode System ---
    const MOBILE_KEY = "XGUI_MOBILE_MODE_ENABLED";
    
    function enableMobile() {
        localStorage.setItem(MOBILE_KEY, "true");
        document.body.classList.add("xgui-mobile-mode");
        // Adjust GUI width for mobile view
        gui.style.width = "430px";
        guiContent.style.left = "75px";
    }
    
    function disableMobile() {
        localStorage.removeItem(MOBILE_KEY);
        document.body.classList.remove("xgui-mobile-mode");
        // Restore default width
        gui.style.width = "800px";
        guiContent.style.left = "70px";
    }
    
    // Auto-load mobile mode if previously enabled
    if (localStorage.getItem(MOBILE_KEY) === "true") {
        setTimeout(() => enableMobile(), 50);
    }
    
    const mobileToggleBtn = createButton('Toggle Mobile Mode', () => {
        if (document.body.classList.contains("xgui-mobile-mode")) {
            disableMobile();
        } else {
            enableMobile();
        }
    });
    contentPages.settings.appendChild(mobileToggleBtn);

    // --- Settings: Keybinds ---
    const defaultHideKey = { ctrl: true, shift: false, alt: false, key: "e" };
    const defaultCloseKey = { ctrl: true, shift: false, alt: false, key: "x" };

    // Helper to parse keybind for display
    function parseKeybind({ shift, ctrl, alt, key }) {
        return [ctrl && "Ctrl", shift && "Shift", alt && "Alt", key && key.toUpperCase()].filter(Boolean).join(" + ");
    }

    // Helper to listen for keybinds
    function createKeybindListener(onpress, element = window) {
        return new Promise((resolve) => {
            const pressed = new Set();
            let shift, ctrl, alt, key;
            const keydown = (e) => {
                e.preventDefault();
                pressed.add(e.code);
                shift ||= e.shiftKey;
                ctrl ||= e.ctrlKey;
                alt ||= e.altKey;
                if (!["shift", "control", "alt", "meta"].includes(e.key.toLowerCase())) key = e.key.toLowerCase();
                onpress?.({ shift, ctrl, alt, key });
            };
            const keyup = (e) => {
                pressed.delete(e.code);
                if (pressed.size > 0) return;
                element.removeEventListener("keydown", keydown);
                element.removeEventListener("keyup", keyup);
                resolve({ shift, ctrl, alt, key });
            };
            element.addEventListener("keydown", keydown);
            element.addEventListener("keyup", keyup);
        });
    }

    // Store Settings in LocalStorage
    const settingsStore = {
        data: JSON.parse(localStorage.getItem("PhysicsGUISettings") || "{}"),
        save() {
            localStorage.setItem("PhysicsGUISettings", JSON.stringify(this.data));
        }
    };
    
    // Initialize defaults if missing
    settingsStore.data.hideKey ??= defaultHideKey;
    settingsStore.data.closeKey ??= defaultCloseKey;

    // Function to create a Keybind Setting Row
    function createKeybindSetting(name, description, keyName) {
        const container = document.createElement('div');
        container.style.cssText = "display: flex; justify-content: space-between; align-items: center; background: var(--background); padding: 10px; border-radius: 5px; margin-bottom: 5px;";
        
        const info = document.createElement('div');
        info.innerHTML = `<strong>${name}</strong><br><small>${description}</small>`;
        
        const input = document.createElement('input');
        input.readOnly = true;
        input.style.cssText = "width: 120px; padding: 5px; background: var(--background2); border: 1px solid var(--highlight); color: var(--textColor); text-align: center; cursor: pointer;";
        input.value = parseKeybind(settingsStore.data[keyName]);
        
        input.onclick = async () => {
            input.value = "Press keys...";
            const keys = await createKeybindListener((k) => input.value = parseKeybind(k));
            settingsStore.data[keyName] = keys;
            settingsStore.save();
            input.value = parseKeybind(keys);
        };
        
        container.append(info, input);
        return container;
    }
    
    contentPages.settings.appendChild(createKeybindSetting("Hide Keybind", "Toggle GUI visibility", "hideKey"));
    contentPages.settings.appendChild(createKeybindSetting("Close Keybind", "Close GUI & stop toggles", "closeKey"));

    // --- Settings: Themes ---
    const themes = {
        "X-GUI ORIGINAL": {
            highlight: "#8A2BE2", highlight2: "#4B0082", background: "#0B0B1E", background2: "#151534",
            textColor: "#E0E0FF", textColor2: "#9A8CFF", toggleOff: "#2C273F", toggleOn: "#5FA3FF"
        },
        "Crypto Hack": {
            highlight: "rgb(88 175 88)", toggleOn: "#0b601b", background: "radial-gradient(#11581e,#041607)",
            background2: "#1a1a1a", toggleOff: "#A02626", highlight2: "#49d149", textColor2: "#49d149"
        },
        "Factory": {
            highlight: "#1563bf", toggleOn: "rgb(75, 194, 46)", background: "#3a3a3a", background2: "#2d313d",
            toggleOff: "#9a49aa", highlight2: "rgb(0 0 0 / 25%)", textColor2: "#a5aabe"
        },
        "Cafe": {
            highlight: "#0bc2cf", toggleOn: "#47A547", background: "linear-gradient(90deg,rgba(200,0,0,.5) 50%,transparent 0) center / 50px 50px,linear-gradient(rgba(200,0,0,0.5) 50%,transparent 0) white center / 50px 50px",
            background2: "rgb(64, 64, 64)", toggleOff: "#A02626", highlight2: "rgb(0 0 0 / 25%)", textColor2: "#ac7339", textColor: "#FFFFFF"
        }
    };

    const themeLabel = document.createElement('div');
    themeLabel.innerText = "Themes:";
    themeLabel.style.cssText = "color: var(--textColor); font-weight: 800; margin-top: 15px; margin-bottom: 5px;";
    contentPages.settings.appendChild(themeLabel);

    Object.keys(themes).forEach(themeName => {
        const btn = createButton(themeName, () => {
            const t = themes[themeName];
            for (const prop in t) {
                // FIXED: Correct property setting
                gui.style.setProperty("--" + prop, t[prop]);
                settingsStore.data.theme = settingsStore.data.theme || {};
                settingsStore.data.theme[prop] = t[prop];
            }
            settingsStore.save();
            // Update visual feedback
            path.updatePath(); 
        });
        contentPages.settings.appendChild(btn);
    });

    // === Sidebar Navigation ===
    function createSidebarPath(name, icon, page) {
        const sidebarPath = document.createElement("div");
        Object.assign(sidebarPath.style, {
            display: 'flex',
            alignItems: 'center',
            cursor: 'pointer',
            padding: '10px',
            transition: 'all 0.2s',
            color: 'var(--textColor)'
        });
        
        sidebarPath.className = 'X-Gui-sidebarPath';
        
        const iconElement = document.createElement("div");
        iconElement.innerHTML = icon;
        Object.assign(iconElement.style, {
            width: '30px',
            height: '30px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            marginRight: '10px',
            fontSize: '18px'
        });
        
        const nameElement = document.createElement("span");
        nameElement.innerText = name;
        Object.assign(nameElement.style, {
            fontSize: '14px',
            fontWeight: '700'
        });
        
        sidebarPath.appendChild(iconElement);
        sidebarPath.appendChild(nameElement);
        
        sidebarPath.onclick = () => {
            // Hide all pages
            Object.values(contentPages).forEach(p => p.style.display = 'none');
            // Show selected page
            page.style.display = 'flex';
            // Update path text
            pathText.innerText = name;
        };
        
        return sidebarPath;
    }
    
    // Add sidebar paths
    sidebarPaths.appendChild(
        createSidebarPath("Core Controls", '<i class="fas fa-sliders-h"></i>', contentPages.core)
    );
    sidebarPaths.appendChild(
        createSidebarPath("Color Controls", '<i class="fas fa-palette"></i>', contentPages.color)
    );
    sidebarPaths.appendChild(
        createSidebarPath("Particle Effects", '<i class="fas fa-sparkles"></i>', contentPages.particle)
    );
    sidebarPaths.appendChild(
        createSidebarPath("Fun Controls", '<i class="fas fa-gamepad"></i>', contentPages.fun)
    );
    sidebarPaths.appendChild(
        createSidebarPath("Physics Settings", '<i class="fas fa-cog"></i>', contentPages.physics)
    );
    sidebarPaths.appendChild(
        createSidebarPath("Illusions", '<i class="fas fa-hat-wizard"></i>', contentPages.illusions)
    );
    sidebarPaths.appendChild(
        createSidebarPath("Settings", '<i class="fas fa-sliders-h"></i>', contentPages.settings) // NEW SETTINGS TAB
    );
    
    // Show core controls by default
    contentPages.core.style.display = 'flex';
    
    // === Toggle menu with key ===
    window.addEventListener('keydown', (e) => {
        // Use settings data for hide key
        const hideK = settingsStore.data.hideKey;
        if (e.key.toLowerCase() === hideK.key && e.ctrlKey === !!hideK.ctrl && e.shiftKey === !!hideK.shift && e.altKey === !!hideK.alt) {
            gui.style.display = gui.style.display === 'none' ? 'block' : 'none';
        }
    });
    
    // === Helpers ===
    function ensureBlocks(count) {
        while (blocks.length < count) {
            blocks.push(makeBlock(Math.random() * canvas.width, Math.random() * canvas.height));
        }
    }
    
    let draggingBlock = null;
    
    function getPos(e) {
        if (e.touches && e.touches.length) {
            return {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
        }
        return {
            x: e.clientX,
            y: e.clientY
        };
    }
    
    function startDrag(e) {
        const { x, y } = getPos(e);
        prevMouseX = x;
        prevMouseY = y;
        
        for (const b of blocks) {
            if (x > b.x && x < b.x + b.w && y > b.y && y < b.y + b.h) {
                b.isDragging = true;
                draggingBlock = b;
                return;
            }
        }
        
        for (const d of dynamites) {
            if (x > d.x && x < d.x + d.w && y > d.y && y < d.y + d.h) {
                d.isDragging = true;
                return;
            }
        }
    }
    
    function moveDrag(e) {
        const { x, y } = getPos(e);
        
        if (draggingBlock) {
            draggingBlock.x += x - prevMouseX;
            draggingBlock.y += y - prevMouseY;
            draggingBlock.vx = (x - prevMouseX) * 0.8;
            draggingBlock.vy = (y - prevMouseY) * 0.8;
            draggingBlock.angularVelocity = (x - prevMouseX) * 0.01;
        }
        
        prevMouseX = x;
        prevMouseY = y;
    }
    
    function endDrag() {
        if (draggingBlock) draggingBlock.isDragging = false;
        draggingBlock = null;
        dynamites.forEach((d) => (d.isDragging = false));
    }
    
    canvas.addEventListener('mousemove', (e) => {
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        mouseX = e.clientX;
        mouseY = e.clientY;
    });
    
    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', moveDrag);
    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('touchstart', startDrag);
    canvas.addEventListener('touchmove', moveDrag);
    canvas.addEventListener('touchend', endDrag);
    
    window.addEventListener('resize', () => {
        canvas.width = innerWidth;
        canvas.height = innerHeight;
    });
    
    // === OPTIMIZATION: Improved Collision Detection with Spatial Grid ===
    function handleCollisions() {
        // Skip collision checks on some frames for performance
        if (frameCount % performanceSettings.collisionCheckInterval !== 0) return 0;
        
        const newCollisions = new Set();
        let hasRolling = false;
        let collisionCount = 0;
        
        // Clear and repopulate spatial grid
        spatialGrid.clear();
        blocks.forEach(block => spatialGrid.addObject(block));
        
        blocks.forEach((block, i) => {
            const nearby = spatialGrid.getNearbyObjects(block);
            nearby.forEach(other => {
                const j = blocks.indexOf(other);
                if (i >= j) return; // Skip self and already checked pairs
                
                if (
                    block.x < other.x + other.w &&
                    block.x + block.w > other.x &&
                    block.y < other.y + other.h &&
                    block.y + block.h > other.y
                ) {
                    const overlapX = Math.min(block.x + block.w - other.x, other.x + other.w - block.x);
                    const overlapY = Math.min(block.y + block.h - other.y, other.y + other.h - block.y);
                    const id = `${i}-${j}`;
                    newCollisions.add(id);
                    
                    const relV = Math.sqrt((block.vx - other.vx) ** 2 + (block.vy - other.vy) ** 2);
                    if (overlapY > overlapX && relV > 0.5 && relV < 3) hasRolling = true;
                    
                    if (!activeCollisions.has(id) && soundCooldowns.collision <= 0) {
                        playSound('collision');
                        soundCooldowns.collision = SOUND_COOLDOWN_TIME;
                    }
                    
                    // FIXED: Proper collision response
                    if (overlapX < overlapY) {
                        // Separate blocks horizontally
                        const sx = overlapX * 0.5;
                        if (block.x < other.x) {
                            block.x -= sx;
                            other.x += sx;
                        } else {
                            block.x += sx;
                            other.x -= sx;
                        }
                        
                        // Calculate proper impulse for horizontal collision
                        const dvx = block.vx - other.vx;
                        const totalMass = block.mass + other.mass;
                        const impulse = ((1 + restitution) * dvx) / totalMass;
                        
                        // Apply impulse based on mass ratio
                        block.vx -= impulse * other.mass;
                        other.vx += impulse * block.mass;
                        
                        // Add some rotation from collision
                        block.rotationSpeed += (Math.random() - 0.5) * 0.05;
                        other.rotationSpeed += (Math.random() - 0.5) * 0.05;
                    } else {
                        // Separate blocks vertically
                        const sy = overlapY * 0.5;
                        if (block.y < other.y) {
                            block.y -= sy;
                            other.y += sy;
                        } else {
                            block.y += sy;
                            other.y -= sy;
                        }
                        
                        // Calculate proper impulse for vertical collision
                        const dvy = block.vy - other.vy;
                        const totalMass = block.mass + other.mass;
                        const impulse = ((1 + restitution) * dvy) / totalMass;
                        
                        // Apply impulse based on mass ratio
                        block.vy -= impulse * other.mass;
                        other.vy += impulse * block.mass;
                        
                        // Add some rotation from collision
                        block.rotationSpeed += (Math.random() - 0.5) * 0.05;
                        other.rotationSpeed += (Math.random() - 0.5) * 0.05;
                    }
                    
                    collisionCount++;
                }
            });
        });
        
        if (hasRolling && soundCooldowns.rolling <= 0) {
            playSound('rolling');
            soundCooldowns.rolling = 200;
        }
        
        activeCollisions.clear();
        newCollisions.forEach((id) => activeCollisions.add(id));
        return collisionCount;
    }
    
    function applyMagnetize() {
        const mx = lastMouseX;
        const my = lastMouseY;
        blocks.forEach((b) => {
            const dx = mx - (b.x + b.w / 2);
            const dy = my - (b.y + b.h / 2);
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const dir = magnetInvert ? -1 : 1;
            
            // FIXED: Better magnet strength calculation with falloff
            const maxForce = magnetStrength * 50;
            const force = Math.min(maxForce, maxForce / (dist * 0.01));
            
            // Apply force with velocity damping to prevent overshooting
            const forceX = (dx / dist) * force * dir * 0.1;
            const forceY = (dy / dist) * force * dir * 0.1;
            b.vx += forceX;
            b.vy += forceY;
            
            // Add slight rotation toward mouse
            const angleToMouse = Math.atan2(dy, dx);
            b.rotationSpeed += (angleToMouse - b.rotation) * 0.01;
        });
    }
    
    function applyCenterPull() {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        blocks.forEach((b) => {
            const dx = cx - (b.x + b.w / 2);
            const dy = cy - (b.y + b.h / 2);
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            
            // FIXED: Better center pull with gentle force and falloff
            const maxForce = 80;
            const force = Math.min(maxForce, maxForce / (dist * 0.02));
            
            // Apply gentle pulling force
            b.vx += (dx / dist) * force * 0.05;
            b.vy += (dy / dist) * force * 0.05;
            
            // Add orbital rotation for visual effect
            const angleToCenter = Math.atan2(dy, dx);
            b.rotationSpeed += Math.sin(angleToCenter) * 0.02;
        });
    }
    
    // === Illusion layouts ===
    function applyIllusions(t) {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        if (illusionsActive.spiral) {
            ensureBlocks(80);
            const turns = 3;
            const speed = 0.8;
            blocks.forEach((b, i) => {
                const a = (i / blocks.length) * turns * Math.PI * 2 + t * speed;
                const r = (i / blocks.length) * Math.min(cx, cy) * 0.95;
                const x = cx + Math.cos(a) * r;
                const y = cy + Math.sin(a) * r;
                b.x = x - 15;
                b.y = y - 15;
                b.displayW = b.displayH = 30;
                b.w = b.h = 30;
                b.color = (i + Math.floor(t * 4 + r / 40)) % 2 === 0 ? '#000' : '#fff';
                b.shape = 'rectangle';
                b.rotation = a + Math.PI / 2;
            });
        }
        
        if (illusionsActive.breathingGrid) {
            ensureBlocks(80);
            const cols = 10;
            const rows = 8;
            const amp = 0.4;
            const scale = 1 + Math.sin(t * 2) * amp;
            const cellW = (canvas.width * 0.8) / cols;
            const cellH = (canvas.height * 0.8) / rows;
            let idx = 0;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++, idx++) {
                    const b = blocks[idx];
                    const baseX = canvas.width * 0.1 + c * cellW;
                    const baseY = canvas.height * 0.1 + r * cellH;
                    b.displayW = b.displayH = Math.min(cellW, cellH) * 0.6 * scale;
                    b.w = b.h = b.displayW;
                    b.x = baseX + cellW / 2 - b.displayW / 2;
                    b.y = baseY + cellH / 2 - b.displayH / 2;
                    b.color = (c + r) % 2 === 0 ? '#fff' : '#000';
                    b.shape = 'rectangle';
                    b.rotation = 0;
                }
            }
        }
        
        if (illusionsActive.waveTunnel) {
            ensureBlocks(80);
            const layers = 6;
            blocks.forEach((b, i) => {
                const ring = i % layers;
                const ang = (i / blocks.length) * Math.PI * 2 * layers;
                const baseR = ((ring + 1) / (layers + 1)) * Math.min(cx, cy) * 0.95;
                const r = baseR + Math.sin(t * 3 + ring) * 15;
                const x = cx + Math.cos(ang) * r;
                const y = cy + Math.sin(ang) * r;
                b.x = x - 10;
                b.y = y - 10;
                b.displayW = b.displayH = 20 + ring * 2;
                b.w = b.h = b.displayW;
                b.color = (ring + Math.floor(t * 6)) % 2 === 0 ? '#fff' : '#000';
                b.shape = 'circle';
                b.rotation = 0;
            });
        }
        
        if (illusionsActive.vortex) {
            ensureBlocks(80);
            blocks.forEach((b, i) => {
                const a = (i / blocks.length) * Math.PI * 4 + t * 2;
                const r = (i / blocks.length) * Math.min(cx, cy);
                const x = cx + Math.cos(a) * r;
                const y = cy + Math.sin(a) * r;
                b.x = x - 8;
                b.y = y - 8;
                b.displayW = b.displayH = 16;
                b.w = b.h = 16;
                b.color = i % 2 === 0 ? '#fff' : '#000';
                b.shape = 'triangle';
                b.rotation = a + Math.PI / 2;
            });
        }
        
        if (illusionsActive.orbitRing) {
            ensureBlocks(80);
            const rings = 4;
            const per = Math.floor(blocks.length / rings);
            
            for (let r = 0; r < rings; r++) {
                const radius = ((r + 1) / (rings + 1)) * Math.min(cx, cy) * 0.9;
                for (let j = 0; j < per; j++) {
                    const idx = r * per + j;
                    const b = blocks[idx];
                    const a = (j / per) * Math.PI * 2 + t * (r % 2 === 0 ? 0.8 : -0.8);
                    const x = cx + Math.cos(a) * radius;
                    const y = cy + Math.sin(a) * radius;
                    b.x = x - 6;
                    b.y = y - 6;
                    b.displayW = b.displayH = 12;
                    b.w = b.h = 12;
                    b.color = j % 2 === 0 ? '#fff' : '#000';
                    b.shape = 'circle';
                    b.rotation = 0;
                }
            }
        }
        
        if (illusionsActive.checkerSpin) {
            ensureBlocks(64);
            const n = 8;
            const size = Math.min(canvas.width, canvas.height) * 0.6;
            const cell = size / n;
            const angle = t * 1.2;
            
            for (let i = 0; i < n * n; i++) {
                const b = blocks[i];
                const row = Math.floor(i / n);
                const col = i % n;
                const lx = (col + 0.5) * cell - size / 2;
                const ly = (row + 0.5) * cell - size / 2;
                const rx = lx * Math.cos(angle) - ly * Math.sin(angle);
                const ry = lx * Math.sin(angle) + ly * Math.cos(angle);
                b.displayW = b.displayH = cell * 0.9;
                b.w = b.h = b.displayW;
                b.x = cx + rx - b.displayW / 2;
                b.y = cy + ry - b.displayH / 2;
                b.color = (row + col) % 2 === 0 ? '#fff' : '#000';
                b.shape = 'rectangle';
                b.rotation = 0;
            }
        }
        
        if (illusionsActive.flipStrip) {
            ensureBlocks(40);
            const yCenter = cy;
            blocks.forEach((b, i) => {
                const phase = (i / blocks.length) * Math.PI * 4;
                const offset = Math.sin(t * 4 + phase) * 40;
                b.displayW = 30;
                b.displayH = 30;
                b.w = b.h = 30;
                b.x = (i / blocks.length) * canvas.width;
                b.y = yCenter - b.displayH / 2 + offset * (i % 2 === 0 ? 1 : -1);
                b.color = i % 2 === 0 ? '#fff' : '#000';
                b.shape = 'rectangle';
                b.rotation = 0;
            });
        }
        
        if (illusionsActive.zoomPulse) {
            ensureBlocks(60);
            const layers = 5;
            const per = Math.floor(blocks.length / layers);
            
            for (let r = 0; r < layers; r++) {
                const base = ((r + 1) / (layers + 1)) * Math.min(cx, cy);
                const pulse = 1 + Math.sin(t * 3 + r) * 0.2;
                const radius = base * pulse;
                for (let j = 0; j < per; j++) {
                    const idx = r * per + j;
                    const b = blocks[idx];
                    const a = (j / per) * Math.PI * 2;
                    b.x = cx + Math.cos(a) * radius - 6;
                    b.y = cy + Math.sin(a) * radius - 6;
                    b.displayW = b.displayH = 12;
                    b.w = b.h = 12;
                    b.color = j % 2 === 0 ? '#fff' : '#000';
                    b.shape = 'circle';
                    b.rotation = 0;
                }
            }
        }
        
        if (illusionsActive.swirlField) {
            ensureBlocks(80);
            const R = 200;
            blocks.forEach((b, i) => {
                const dx = b.x + b.w / 2 - mouseX;
                const dy = b.y + b.h / 2 - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const factor = Math.max(0, 1 - dist / R);
                const angle = t * 5 * factor;
                const sx = Math.cos(angle) * dx - Math.sin(angle) * dy;
                const sy = Math.sin(angle) * dx + Math.cos(angle) * dy;
                const x = mouseX + sx;
                const y = mouseY + sy;
                b.displayW = b.displayH = 10 + factor * 15;
                b.w = b.h = b.displayW;
                b.x = x - b.displayW / 2;
                b.y = y - b.displayH / 2;
                b.color = factor > 0.5 ? '#fff' : '#000';
                b.shape = i % 2 === 0 ? 'circle' : 'rectangle';
                b.rotation = 0;
            });
        }
        
        if (illusionsActive.hypnoHue) {
            const hueBase = (t * 80) % 360;
            blocks.forEach((b, i) => {
                const f = i / Math.max(1, blocks.length);
                const hue = (hueBase + f * 180) % 360;
                b.color = `hsl(${hue},100%,60%)`;
            });
        }
    }
    
    // === Dynamite explosion ===
    function explode(d) {
        d.exploded = true;
        playSound('explosion');
        const blastRadius = 250;
        const blastPower = 50;
        blocks.forEach((b) => {
            const dx = b.x + b.w / 2 - (d.x + d.w / 2);
            const dy = b.y + b.h / 2 - (d.y + d.h / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < blastRadius && dist > 0) {
                const force = (1 - dist / blastRadius) * blastPower;
                b.vx += (dx / dist) * force;
                b.vy += (dy / dist) * force - 8;
                b.angularVelocity = (Math.random() - 0.5) * 0.4;
            }
        });
        for (let i = 0; i < 30; i++) {
            const particle = makeParticle(d.x + d.w / 2, d.y + d.h / 2, d.color);
            particles.push(particle);
        }
        const start = performance.now();
        const tick = () => {
            if (performance.now() - start < 500) {
                requestAnimationFrame(tick);
            } else {
                const idx = dynamites.indexOf(d);
                if (idx !== -1) dynamites.splice(idx, 1);
            }
        };
        tick();
    }
    
    // === OPTIMIZATION: Improved Update Loop ===
    function update() {
        frameCount++;
        
        // OPTIMIZATION: Skip color pulse updates on some frames
        if (frameCount % 2 === 0 && colorPulseMode) {
            pulsePhase += pulseSpeed;
            if (pulsePhase > 1) pulsePhase = 0;
        }
        
        // Sound cooldowns
        for (const k in soundCooldowns) {
            if (soundCooldowns[k] > 0) soundCooldowns[k] -= 16.67;
        }
        
        // OPTIMIZATION: Skip particle updates on some frames
        if (frameCount % performanceSettings.particleUpdateInterval === 0) {
            updateEffectParticles();
        }
        
        const t = performance.now() / 1000;
        if (gravityWave) {
            gravity = 0.6 + Math.sin(t * 2) * 0.4;
        }
        if (gravitySpin) {
            gravityDir = Math.sin(t) >= 0 ? 1 : -1;
        }
        
        // OPTIMIZATION: Skip physics updates for off-screen blocks and limit processed blocks
        const screenBounds = {
            left: -100,
            right: canvas.width + 100,
            top: -100,
            bottom: canvas.height + 100
        };
        
        // Process all blocks
        const blocksToProcess = blocks;
        blocksToProcess.forEach((b) => {
            // Skip off-screen blocks
            if (b.x + b.w < screenBounds.left || b.x > screenBounds.right || b.y + b.h < screenBounds.top || b.y > screenBounds.bottom) {
                return;
            }
            
            // OPTIMIZATION: Simplified trail updates
            if (b.vx !== 0 || b.vy !== 0) {
                b.trail.push({
                    x: b.x + b.w / 2,
                    y: b.y + b.h / 2,
                    age: 0
                });
                if (b.trail.length > b.maxTrailLength) b.trail.shift();
            }
            
            if (frameCount % 4 === 0) {
                // Update trail age less frequently
                b.trail.forEach((p) => p.age++);
            }
            
            // Shrink / grow target
            if (shrinkMode || growMode) {
                b.displayW += (targetSize.width - b.displayW) * 0.1;
                b.displayH += (targetSize.height - b.displayH) * 0.1;
                b.w = b.displayW;
                b.h = b.displayH;
            }
            
            if (!b.isDragging) {
                // Gravity
                if (antiGravityMode) {
                    b.vy -= gravity * 0.5 * slowMo;
                } else if (verticalMovement) {
                    b.vy += gravity * gravityDir * slowMo;
                }
                
                // Air resistance
                b.vx *= airResistance;
                b.vy *= airResistance;
                if (!horizontalMovement) b.vx = 0;
                
                // FIXED: Proper tornado effect
                if (tornadoMode) {
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2;
                    const dx = b.x + b.w / 2 - cx;
                    const dy = b.y + b.h / 2 - cy;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    // Calculate tangential force for spiral motion
                    const angle = Math.atan2(dy, dx);
                    const tangentX = -Math.sin(angle);
                    const tangentY = Math.cos(angle);
                    
                    // Stronger spiral force with distance falloff
                    const spiralStrength = 150 / Math.max(1, dist * 0.01);
                    const pullStrength = 50 / Math.max(1, dist * 0.01);
                    
                    // Apply spiral motion and inward pull
                    b.vx += tangentX * spiralStrength * 0.1 - (dx / dist) * pullStrength * 0.05;
                    b.vy += tangentY * spiralStrength * 0.1 - (dy / dist) * pullStrength * 0.05;
                    
                    // Add spinning motion
                    b.rotationSpeed += 0.1;
                }
                
                // Integrate
                b.x += b.vx * slowMo;
                b.y += b.vy * slowMo;
                
                // Rotation (OPTIMIZATION: Simplified)
                if (rotateMode) {
                    b.rotation += (b.rotationSpeed || 0.05);
                    b.rotationSpeed *= 0.99; // Simplified damping
                }
                
                // Size wave
                if (sizeWaveMode) {
                    const wave = Math.sin(performance.now() / 500 + b.x / 100);
                    b.w = blockSize + wave * 30;
                    b.h = blockSize + wave * 30;
                    b.displayW = b.w;
                    b.displayH = b.h;
                }
                
                // Wall collisions (use collisionEnergyLoss)
                let bounced = false;
                const energyLoss = 1 - (physicsSettings.collisionEnergyLoss || 0);
                
                // Bottom
                if (b.y + b.h > canvas.height) {
                    b.y = canvas.height - b.h;
                    b.vy *= -wallBounce * energyLoss;
                    b.vx *= friction;
                    bounced = true;
                } else if (b.y < 0) {
                    // Top
                    b.y = 0;
                    b.vy *= -wallBounce * energyLoss;
                    b.vx *= friction;
                    bounced = true;
                }
                
                // Right
                if (b.x + b.w > canvas.width) {
                    b.x = canvas.width - b.w;
                    b.vx *= -wallBounce * energyLoss;
                    b.vy *= friction;
                    bounced = true;
                } else if (b.x < 0) {
                    // Left
                    b.x = 0;
                    b.vx *= -wallBounce * energyLoss;
                    b.vy *= friction;
                    bounced = true;
                }
                
                if (bounced && soundCooldowns.bounce <= 0) {
                    const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                    if (speed > 2) {
                        playSound('bounce');
                        soundCooldowns.bounce = SOUND_COOLDOWN_TIME;
                    }
                }
            }
            
            // OPTIMIZATION: Skip color updates on some frames
            if (frameCount % 3 === 0) {
                // Color modes
                if (colorPulseMode) {
                    const f = (Math.sin(pulsePhase * Math.PI * 2) + 1) / 2;
                    b.color = interpolateColor(pulseColor1, pulseColor2, f);
                } else if (rainbowMode) {
                    b.color = `hsl(${(performance.now() / 10 + b.x) % 360},100%,60%)`;
                } else if (randomFrameColors) {
                    b.color = randomColor();
                }
            }
        });
        
        // Illusions override layout/colors as needed
        applyIllusions(t);
        
        // Dynamites (OPTIMIZATION: Simplified)
        dynamites.forEach((d) => {
            if (d.exploded) return;
            if (!d.isDragging) {
                d.vy += gravity;
                d.vx *= airResistance;
                d.vy *= airResistance;
                d.x += d.vx;
                d.y += d.vy;
                if (d.y + d.h > canvas.height) {
                    d.y = canvas.height - d.h;
                    d.vy *= -0.3;
                    d.vx *= 0.8;
                }
            }
            d.timer--;
            if (d.timer <= 0 && !d.exploded) explode(d);
        });
        
        // OPTIMIZATION: Particle cleanup and pooling
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.vy += p.gravity || 0.2;
            p.vx *= p.airResistance || 0.99;
            p.vy *= p.airResistance || 0.99;
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            
            if (p.life <= 0) {
                // Return to pool
                if (particlePool.length < 100) {
                    particlePool.push(p);
                }
                particles.splice(i, 1);
            }
        }
        
        if (magnetize) applyMagnetize();
        if (centerPull) applyCenterPull();
        if (collisionsEnabled) handleCollisions();
    }
    
    // === OPTIMIZATION: Improved Draw Loop ===
    function draw() {
        // Skip rendering on some frames for performance
        if (frameCount % performanceSettings.renderInterval !== 0) return;
        
        if (!trailMode) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = 'rgba(0,0,0,0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Draw all particles
        const visibleParticles = particles.filter(p => p.x > -50 && p.x < canvas.width + 50 && p.y > -50 && p.y < canvas.height + 50);
        
        // OPTIMIZATION: Simplified trail rendering
        if (trailMode) {
            ctx.lineWidth = 2;
            blocks.forEach((b) => {
                if (b.trail.length > 1) {
                    ctx.strokeStyle = b.color;
                    ctx.beginPath();
                    const trailStep = Math.max(1, Math.floor(b.trail.length / 10)); // Draw every Nth trail point
                    for (let i = 0; i < b.trail.length; i += trailStep) {
                        const pt = b.trail[i];
                        const alpha = (1 - pt.age / b.maxTrailLength) * 0.5;
                        ctx.globalAlpha = alpha;
                        if (i === 0) {
                            ctx.moveTo(pt.x, pt.y);
                        } else {
                            ctx.lineTo(pt.x, pt.y);
                        }
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            });
        }
        
        // Draw all effect particles
        effectParticles.forEach((p) => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / (p.maxLife || 100);
            
            if (p.type === 'sparkle' && p.twinkle) {
                ctx.globalAlpha *= Math.abs(Math.sin(p.twinkle));
            }
            
            if (p.type === 'electric' && p.intensity) {
                ctx.globalAlpha *= 0.3 + p.intensity * 0.7;
            }
            
            if (p.type === 'plasma' && p.energy) {
                ctx.globalAlpha *= 0.5 + Math.sin(performance.now() / 100 + p.energy * 10) * 0.5;
            }
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
        
        // OPTIMIZATION: Simplified particle rendering
        visibleParticles.forEach((p) => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 100;
            // OPTIMIZATION: Use fillRect instead of arc for better performance
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        });
        ctx.globalAlpha = 1;
        
        // Draw all visible blocks
        const visibleBlocks = blocks.filter(b => b.x + b.w > -50 && b.x < canvas.width + 50 && b.y + b.h > -50 && b.y < canvas.height + 50);
        
        // OPTIMIZATION: Batch render blocks by type to reduce state changes
        const rectangles = visibleBlocks.filter(b => b.shape === 'rectangle');
        const circles = visibleBlocks.filter(b => b.shape === 'circle');
        const triangles = visibleBlocks.filter(b => b.shape === 'triangle');
        
        // Render rectangles
        rectangles.forEach((b) => {
            ctx.fillStyle = flashMode ? randomColor() : b.color;
            // OPTIMIZATION: Skip shadows for better performance
            ctx.fillRect(b.x, b.y, b.displayW, b.displayH);
        });
        
        // Render circles
        circles.forEach((b) => {
            ctx.fillStyle = flashMode ? randomColor() : b.color;
            ctx.beginPath();
            ctx.arc(
                b.x + b.displayW / 2,
                b.y + b.displayH / 2,
                b.displayW / 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
        });
        
        // Render triangles
        triangles.forEach((b) => {
            ctx.fillStyle = flashMode ? randomColor() : b.color;
            ctx.beginPath();
            ctx.moveTo(b.x + b.displayW / 2, b.y);
            ctx.lineTo(b.x, b.y + b.displayH);
            ctx.lineTo(b.x + b.displayW, b.y + b.displayH);
            ctx.closePath();
            ctx.fill();
        });
        
        // OPTIMIZATION: Simplified dynamite rendering
        dynamites.forEach((d) => {
            if (d.exploded) return;
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(d.x + 5, d.y + 10, d.w - 10, d.h - 20);
            ctx.fillStyle = d.color;
            ctx.fillRect(d.x, d.y, d.w, d.h - 20);
            // OPTIMIZATION: Simplified fuse rendering
            if (d.timer < 60) {
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(d.x + d.w / 2 - 2, d.y - 10, 4, 10);
            }
            ctx.fillStyle = d.timer < 60 ? '#ffff00' : '#000000';
            ctx.font = 'bold 12px Arial';
            ctx.fillText(
                Math.ceil(d.timer / 60),
                d.x + d.w / 2 - 5,
                d.y + d.h / 2 + 5
            );
        });
    }
    
    // === OPTIMIZATION: Performance Monitor ===
    let lastPerfUpdate = performance.now();
    let fps = 60;
    
    function updatePerformanceMonitor() {
        const now = performance.now();
        if (now - lastPerfUpdate >= 1000) {
            fps = Math.round(1000 / (now - lastPerfUpdate) * frameCount);
            frameCount = 0;
            lastPerfUpdate = now;
            
            // Log performance warnings
            if (fps < 30 && blocks.length > 50) {
                console.warn(`⚠️ Low FPS: ${fps} with ${blocks.length} shapes. Consider reducing shape count.`);
            }
            
            if (fps < 20) {
                // Auto-adjust performance settings
                performanceSettings.collisionCheckInterval = Math.min(4, performanceSettings.collisionCheckInterval + 1);
                performanceSettings.particleUpdateInterval = Math.min(3, performanceSettings.particleUpdateInterval + 1);
                performanceSettings.renderInterval = Math.min(2, performanceSettings.renderInterval + 1);
                console.log(`🔧 Auto-adjusting performance settings. FPS: ${fps}`);
            } else if (fps > 55) {
                // Restore full performance
                performanceSettings.collisionCheckInterval = 2;
                performanceSettings.particleUpdateInterval = 2;
                performanceSettings.renderInterval = 1;
            }
        }
    }
    
    // === Animation loop ===
    function animate() {
        update();
        draw();
        updatePerformanceMonitor();
        requestAnimationFrame(animate);
    }
    
    // Initialize audio context on first interaction
    document.addEventListener('click', () => {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }, {
        once: true
    });
    
    animate();
})(); // end IIFE

// --- Autoclicker setup ---
let autoclickerRunning = false;
let clickInterval;
let mouseX = 0;
let mouseY = 0;

window.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

function clickUnderCursor() {
    const el = document.elementFromPoint(mouseX, mouseY);
    if (!el) return;
    const evt = new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: true,
        clientX: mouseX,
        clientY: mouseY,
        button: 0
    });
    el.dispatchEvent(evt);
}

function startAutoclicker() {
    clickInterval = setInterval(clickUnderCursor, 1);
    console.log("Autoclicker started! Press ']' to stop.");
}

function stopAutoclicker() {
    clearInterval(clickInterval);
    console.log('Autoclicker stopped!');
}

document.addEventListener('keydown', (e) => {
    if (e.key === ']') {
        if (autoclickerRunning) {
            stopAutoclicker();
        } else {
            startAutoclicker();
        }
        autoclickerRunning = !autoclickerRunning;
    }
});

console.log(
    "Autoclicker ready! Hover over an element and press ']' to start/stop left-clicking."
);